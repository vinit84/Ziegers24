{"ast":null,"code":"!function (t, n) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = n() : \"function\" == typeof define && define.amd ? define(n) : (t = t || self).barba = n();\n}(this, function () {\n  function t(t, n) {\n    for (var r = 0; r < n.length; r++) {\n      var e = n[r];\n      e.enumerable = e.enumerable || !1, e.configurable = !0, \"value\" in e && (e.writable = !0), Object.defineProperty(t, e.key, e);\n    }\n  }\n  function n(n, r, e) {\n    return r && t(n.prototype, r), e && t(n, e), n;\n  }\n  function r() {\n    return (r = Object.assign || function (t) {\n      for (var n = 1; n < arguments.length; n++) {\n        var r = arguments[n];\n        for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (t[e] = r[e]);\n      }\n      return t;\n    }).apply(this, arguments);\n  }\n  function e(t, n) {\n    t.prototype = Object.create(n.prototype), t.prototype.constructor = t, t.__proto__ = n;\n  }\n  function i(t) {\n    return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    })(t);\n  }\n  function o(t, n) {\n    return (o = Object.setPrototypeOf || function (t, n) {\n      return t.__proto__ = n, t;\n    })(t, n);\n  }\n  function u(t, n, r) {\n    return (u = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }() ? Reflect.construct : function (t, n, r) {\n      var e = [null];\n      e.push.apply(e, n);\n      var i = new (Function.bind.apply(t, e))();\n      return r && o(i, r.prototype), i;\n    }).apply(null, arguments);\n  }\n  function f(t) {\n    var n = \"function\" == typeof Map ? new Map() : void 0;\n    return (f = function (t) {\n      if (null === t || -1 === Function.toString.call(t).indexOf(\"[native code]\")) return t;\n      if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n      if (void 0 !== n) {\n        if (n.has(t)) return n.get(t);\n        n.set(t, r);\n      }\n      function r() {\n        return u(t, arguments, i(this).constructor);\n      }\n      return r.prototype = Object.create(t.prototype, {\n        constructor: {\n          value: r,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), o(r, t);\n    })(t);\n  }\n  function s(t, n) {\n    try {\n      var r = t();\n    } catch (t) {\n      return n(t);\n    }\n    return r && r.then ? r.then(void 0, n) : r;\n  }\n  \"undefined\" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))), \"undefined\" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")));\n  var c,\n    a = \"2.9.7\",\n    h = function () {};\n  !function (t) {\n    t[t.off = 0] = \"off\", t[t.error = 1] = \"error\", t[t.warning = 2] = \"warning\", t[t.info = 3] = \"info\", t[t.debug = 4] = \"debug\";\n  }(c || (c = {}));\n  var v = c.off,\n    l = function () {\n      function t(t) {\n        this.t = t;\n      }\n      t.getLevel = function () {\n        return v;\n      }, t.setLevel = function (t) {\n        return v = c[t];\n      };\n      var n = t.prototype;\n      return n.error = function () {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];\n        this.i(console.error, c.error, n);\n      }, n.warn = function () {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];\n        this.i(console.warn, c.warning, n);\n      }, n.info = function () {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];\n        this.i(console.info, c.info, n);\n      }, n.debug = function () {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];\n        this.i(console.log, c.debug, n);\n      }, n.i = function (n, r, e) {\n        r <= t.getLevel() && n.apply(console, [\"[\" + this.t + \"] \"].concat(e));\n      }, t;\n    }(),\n    d = O,\n    m = E,\n    p = g,\n    w = x,\n    b = T,\n    y = \"/\",\n    P = new RegExp([\"(\\\\\\\\.)\", \"(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?\"].join(\"|\"), \"g\");\n  function g(t, n) {\n    for (var r, e = [], i = 0, o = 0, u = \"\", f = n && n.delimiter || y, s = n && n.whitelist || void 0, c = !1; null !== (r = P.exec(t));) {\n      var a = r[0],\n        h = r[1],\n        v = r.index;\n      if (u += t.slice(o, v), o = v + a.length, h) u += h[1], c = !0;else {\n        var l = \"\",\n          d = r[2],\n          m = r[3],\n          p = r[4],\n          w = r[5];\n        if (!c && u.length) {\n          var b = u.length - 1,\n            g = u[b];\n          (!s || s.indexOf(g) > -1) && (l = g, u = u.slice(0, b));\n        }\n        u && (e.push(u), u = \"\", c = !1);\n        var E = m || p,\n          x = l || f;\n        e.push({\n          name: d || i++,\n          prefix: l,\n          delimiter: x,\n          optional: \"?\" === w || \"*\" === w,\n          repeat: \"+\" === w || \"*\" === w,\n          pattern: E ? A(E) : \"[^\" + k(x === f ? x : x + f) + \"]+?\"\n        });\n      }\n    }\n    return (u || o < t.length) && e.push(u + t.substr(o)), e;\n  }\n  function E(t, n) {\n    return function (r, e) {\n      var i = t.exec(r);\n      if (!i) return !1;\n      for (var o = i[0], u = i.index, f = {}, s = e && e.decode || decodeURIComponent, c = 1; c < i.length; c++) if (void 0 !== i[c]) {\n        var a = n[c - 1];\n        f[a.name] = a.repeat ? i[c].split(a.delimiter).map(function (t) {\n          return s(t, a);\n        }) : s(i[c], a);\n      }\n      return {\n        path: o,\n        index: u,\n        params: f\n      };\n    };\n  }\n  function x(t, n) {\n    for (var r = new Array(t.length), e = 0; e < t.length; e++) \"object\" == typeof t[e] && (r[e] = new RegExp(\"^(?:\" + t[e].pattern + \")$\", R(n)));\n    return function (n, e) {\n      for (var i = \"\", o = e && e.encode || encodeURIComponent, u = !e || !1 !== e.validate, f = 0; f < t.length; f++) {\n        var s = t[f];\n        if (\"string\" != typeof s) {\n          var c,\n            a = n ? n[s.name] : void 0;\n          if (Array.isArray(a)) {\n            if (!s.repeat) throw new TypeError('Expected \"' + s.name + '\" to not repeat, but got array');\n            if (0 === a.length) {\n              if (s.optional) continue;\n              throw new TypeError('Expected \"' + s.name + '\" to not be empty');\n            }\n            for (var h = 0; h < a.length; h++) {\n              if (c = o(a[h], s), u && !r[f].test(c)) throw new TypeError('Expected all \"' + s.name + '\" to match \"' + s.pattern + '\"');\n              i += (0 === h ? s.prefix : s.delimiter) + c;\n            }\n          } else if (\"string\" != typeof a && \"number\" != typeof a && \"boolean\" != typeof a) {\n            if (!s.optional) throw new TypeError('Expected \"' + s.name + '\" to be ' + (s.repeat ? \"an array\" : \"a string\"));\n          } else {\n            if (c = o(String(a), s), u && !r[f].test(c)) throw new TypeError('Expected \"' + s.name + '\" to match \"' + s.pattern + '\", but got \"' + c + '\"');\n            i += s.prefix + c;\n          }\n        } else i += s;\n      }\n      return i;\n    };\n  }\n  function k(t) {\n    return t.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n  }\n  function A(t) {\n    return t.replace(/([=!:$/()])/g, \"\\\\$1\");\n  }\n  function R(t) {\n    return t && t.sensitive ? \"\" : \"i\";\n  }\n  function T(t, n, r) {\n    for (var e = (r = r || {}).strict, i = !1 !== r.start, o = !1 !== r.end, u = r.delimiter || y, f = [].concat(r.endsWith || []).map(k).concat(\"$\").join(\"|\"), s = i ? \"^\" : \"\", c = 0; c < t.length; c++) {\n      var a = t[c];\n      if (\"string\" == typeof a) s += k(a);else {\n        var h = a.repeat ? \"(?:\" + a.pattern + \")(?:\" + k(a.delimiter) + \"(?:\" + a.pattern + \"))*\" : a.pattern;\n        n && n.push(a), s += a.optional ? a.prefix ? \"(?:\" + k(a.prefix) + \"(\" + h + \"))?\" : \"(\" + h + \")?\" : k(a.prefix) + \"(\" + h + \")\";\n      }\n    }\n    if (o) e || (s += \"(?:\" + k(u) + \")?\"), s += \"$\" === f ? \"$\" : \"(?=\" + f + \")\";else {\n      var v = t[t.length - 1],\n        l = \"string\" == typeof v ? v[v.length - 1] === u : void 0 === v;\n      e || (s += \"(?:\" + k(u) + \"(?=\" + f + \"))?\"), l || (s += \"(?=\" + k(u) + \"|\" + f + \")\");\n    }\n    return new RegExp(s, R(r));\n  }\n  function O(t, n, r) {\n    return t instanceof RegExp ? function (t, n) {\n      if (!n) return t;\n      var r = t.source.match(/\\((?!\\?)/g);\n      if (r) for (var e = 0; e < r.length; e++) n.push({\n        name: e,\n        prefix: null,\n        delimiter: null,\n        optional: !1,\n        repeat: !1,\n        pattern: null\n      });\n      return t;\n    }(t, n) : Array.isArray(t) ? function (t, n, r) {\n      for (var e = [], i = 0; i < t.length; i++) e.push(O(t[i], n, r).source);\n      return new RegExp(\"(?:\" + e.join(\"|\") + \")\", R(r));\n    }(t, n, r) : function (t, n, r) {\n      return T(g(t, r), n, r);\n    }(t, n, r);\n  }\n  d.match = function (t, n) {\n    var r = [];\n    return E(O(t, r, n), r);\n  }, d.regexpToFunction = m, d.parse = p, d.compile = function (t, n) {\n    return x(g(t, n), n);\n  }, d.tokensToFunction = w, d.tokensToRegExp = b;\n  var S = {\n      container: \"container\",\n      history: \"history\",\n      namespace: \"namespace\",\n      prefix: \"data-barba\",\n      prevent: \"prevent\",\n      wrapper: \"wrapper\"\n    },\n    j = new (function () {\n      function t() {\n        this.o = S, this.u = new DOMParser();\n      }\n      var n = t.prototype;\n      return n.toString = function (t) {\n        return t.outerHTML;\n      }, n.toDocument = function (t) {\n        return this.u.parseFromString(t, \"text/html\");\n      }, n.toElement = function (t) {\n        var n = document.createElement(\"div\");\n        return n.innerHTML = t, n;\n      }, n.getHtml = function (t) {\n        return void 0 === t && (t = document), this.toString(t.documentElement);\n      }, n.getWrapper = function (t) {\n        return void 0 === t && (t = document), t.querySelector(\"[\" + this.o.prefix + '=\"' + this.o.wrapper + '\"]');\n      }, n.getContainer = function (t) {\n        return void 0 === t && (t = document), t.querySelector(\"[\" + this.o.prefix + '=\"' + this.o.container + '\"]');\n      }, n.removeContainer = function (t) {\n        document.body.contains(t) && t.parentNode.removeChild(t);\n      }, n.addContainer = function (t, n) {\n        var r = this.getContainer();\n        r ? this.s(t, r) : n.appendChild(t);\n      }, n.getNamespace = function (t) {\n        void 0 === t && (t = document);\n        var n = t.querySelector(\"[\" + this.o.prefix + \"-\" + this.o.namespace + \"]\");\n        return n ? n.getAttribute(this.o.prefix + \"-\" + this.o.namespace) : null;\n      }, n.getHref = function (t) {\n        if (t.tagName && \"a\" === t.tagName.toLowerCase()) {\n          if (\"string\" == typeof t.href) return t.href;\n          var n = t.getAttribute(\"href\") || t.getAttribute(\"xlink:href\");\n          if (n) return this.resolveUrl(n.baseVal || n);\n        }\n        return null;\n      }, n.resolveUrl = function () {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];\n        var e = n.length;\n        if (0 === e) throw new Error(\"resolveUrl requires at least one argument; got none.\");\n        var i = document.createElement(\"base\");\n        if (i.href = arguments[0], 1 === e) return i.href;\n        var o = document.getElementsByTagName(\"head\")[0];\n        o.insertBefore(i, o.firstChild);\n        for (var u, f = document.createElement(\"a\"), s = 1; s < e; s++) f.href = arguments[s], i.href = u = f.href;\n        return o.removeChild(i), u;\n      }, n.s = function (t, n) {\n        n.parentNode.insertBefore(t, n.nextSibling);\n      }, t;\n    }())(),\n    M = new (function () {\n      function t() {\n        this.h = [], this.v = -1;\n      }\n      var e = t.prototype;\n      return e.init = function (t, n) {\n        this.l = \"barba\";\n        var r = {\n          ns: n,\n          scroll: {\n            x: window.scrollX,\n            y: window.scrollY\n          },\n          url: t\n        };\n        this.h.push(r), this.v = 0;\n        var e = {\n          from: this.l,\n          index: 0,\n          states: [].concat(this.h)\n        };\n        window.history && window.history.replaceState(e, \"\", t);\n      }, e.change = function (t, n, r) {\n        if (r && r.state) {\n          var e = r.state,\n            i = e.index;\n          n = this.m(this.v - i), this.replace(e.states), this.v = i;\n        } else this.add(t, n);\n        return n;\n      }, e.add = function (t, n) {\n        var r = this.size,\n          e = this.p(n),\n          i = {\n            ns: \"tmp\",\n            scroll: {\n              x: window.scrollX,\n              y: window.scrollY\n            },\n            url: t\n          };\n        this.h.push(i), this.v = r;\n        var o = {\n          from: this.l,\n          index: r,\n          states: [].concat(this.h)\n        };\n        switch (e) {\n          case \"push\":\n            window.history && window.history.pushState(o, \"\", t);\n            break;\n          case \"replace\":\n            window.history && window.history.replaceState(o, \"\", t);\n        }\n      }, e.update = function (t, n) {\n        var e = n || this.v,\n          i = r({}, this.get(e), {}, t);\n        this.set(e, i);\n      }, e.remove = function (t) {\n        t ? this.h.splice(t, 1) : this.h.pop(), this.v--;\n      }, e.clear = function () {\n        this.h = [], this.v = -1;\n      }, e.replace = function (t) {\n        this.h = t;\n      }, e.get = function (t) {\n        return this.h[t];\n      }, e.set = function (t, n) {\n        return this.h[t] = n;\n      }, e.p = function (t) {\n        var n = \"push\",\n          r = t,\n          e = S.prefix + \"-\" + S.history;\n        return r.hasAttribute && r.hasAttribute(e) && (n = r.getAttribute(e)), n;\n      }, e.m = function (t) {\n        return Math.abs(t) > 1 ? t > 0 ? \"forward\" : \"back\" : 0 === t ? \"popstate\" : t > 0 ? \"back\" : \"forward\";\n      }, n(t, [{\n        key: \"current\",\n        get: function () {\n          return this.h[this.v];\n        }\n      }, {\n        key: \"state\",\n        get: function () {\n          return this.h[this.h.length - 1];\n        }\n      }, {\n        key: \"previous\",\n        get: function () {\n          return this.v < 1 ? null : this.h[this.v - 1];\n        }\n      }, {\n        key: \"size\",\n        get: function () {\n          return this.h.length;\n        }\n      }]), t;\n    }())(),\n    L = function (t, n) {\n      try {\n        var r = function () {\n          if (!n.next.html) return Promise.resolve(t).then(function (t) {\n            var r = n.next;\n            if (t) {\n              var e = j.toElement(t);\n              r.namespace = j.getNamespace(e), r.container = j.getContainer(e), r.html = t, M.update({\n                ns: r.namespace\n              });\n              var i = j.toDocument(t);\n              document.title = i.title;\n            }\n          });\n        }();\n        return Promise.resolve(r && r.then ? r.then(function () {}) : void 0);\n      } catch (t) {\n        return Promise.reject(t);\n      }\n    },\n    $ = d,\n    _ = {\n      __proto__: null,\n      update: L,\n      nextTick: function () {\n        return new Promise(function (t) {\n          window.requestAnimationFrame(t);\n        });\n      },\n      pathToRegexp: $\n    },\n    q = function () {\n      return window.location.origin;\n    },\n    B = function (t) {\n      return void 0 === t && (t = window.location.href), U(t).port;\n    },\n    U = function (t) {\n      var n,\n        r = t.match(/:\\d+/);\n      if (null === r) /^http/.test(t) && (n = 80), /^https/.test(t) && (n = 443);else {\n        var e = r[0].substring(1);\n        n = parseInt(e, 10);\n      }\n      var i,\n        o = t.replace(q(), \"\"),\n        u = {},\n        f = o.indexOf(\"#\");\n      f >= 0 && (i = o.slice(f + 1), o = o.slice(0, f));\n      var s = o.indexOf(\"?\");\n      return s >= 0 && (u = D(o.slice(s + 1)), o = o.slice(0, s)), {\n        hash: i,\n        path: o,\n        port: n,\n        query: u\n      };\n    },\n    D = function (t) {\n      return t.split(\"&\").reduce(function (t, n) {\n        var r = n.split(\"=\");\n        return t[r[0]] = r[1], t;\n      }, {});\n    },\n    F = function (t) {\n      return void 0 === t && (t = window.location.href), t.replace(/(\\/#.*|\\/|#.*)$/, \"\");\n    },\n    H = {\n      __proto__: null,\n      getHref: function () {\n        return window.location.href;\n      },\n      getOrigin: q,\n      getPort: B,\n      getPath: function (t) {\n        return void 0 === t && (t = window.location.href), U(t).path;\n      },\n      parse: U,\n      parseQuery: D,\n      clean: F\n    };\n  function I(t, n, r) {\n    return void 0 === n && (n = 2e3), new Promise(function (e, i) {\n      var o = new XMLHttpRequest();\n      o.onreadystatechange = function () {\n        if (o.readyState === XMLHttpRequest.DONE) if (200 === o.status) e(o.responseText);else if (o.status) {\n          var n = {\n            status: o.status,\n            statusText: o.statusText\n          };\n          r(t, n), i(n);\n        }\n      }, o.ontimeout = function () {\n        var e = new Error(\"Timeout error [\" + n + \"]\");\n        r(t, e), i(e);\n      }, o.onerror = function () {\n        var n = new Error(\"Fetch error\");\n        r(t, n), i(n);\n      }, o.open(\"GET\", t), o.timeout = n, o.setRequestHeader(\"Accept\", \"text/html,application/xhtml+xml,application/xml\"), o.setRequestHeader(\"x-barba\", \"yes\"), o.send();\n    });\n  }\n  var C = function (t) {\n    return !!t && (\"object\" == typeof t || \"function\" == typeof t) && \"function\" == typeof t.then;\n  };\n  function N(t, n) {\n    return void 0 === n && (n = {}), function () {\n      for (var r = arguments.length, e = new Array(r), i = 0; i < r; i++) e[i] = arguments[i];\n      var o = !1,\n        u = new Promise(function (r, i) {\n          n.async = function () {\n            return o = !0, function (t, n) {\n              t ? i(t) : r(n);\n            };\n          };\n          var u = t.apply(n, e);\n          o || (C(u) ? u.then(r, i) : r(u));\n        });\n      return u;\n    };\n  }\n  var X = new (function (t) {\n      function n() {\n        var n;\n        return (n = t.call(this) || this).logger = new l(\"@barba/core\"), n.all = [\"ready\", \"page\", \"reset\", \"currentAdded\", \"currentRemoved\", \"nextAdded\", \"nextRemoved\", \"beforeOnce\", \"once\", \"afterOnce\", \"before\", \"beforeLeave\", \"leave\", \"afterLeave\", \"beforeEnter\", \"enter\", \"afterEnter\", \"after\"], n.registered = new Map(), n.init(), n;\n      }\n      e(n, t);\n      var r = n.prototype;\n      return r.init = function () {\n        var t = this;\n        this.registered.clear(), this.all.forEach(function (n) {\n          t[n] || (t[n] = function (r, e) {\n            t.registered.has(n) || t.registered.set(n, new Set()), t.registered.get(n).add({\n              ctx: e || {},\n              fn: r\n            });\n          });\n        });\n      }, r.do = function (t) {\n        for (var n = this, r = arguments.length, e = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) e[i - 1] = arguments[i];\n        if (this.registered.has(t)) {\n          var o = Promise.resolve();\n          return this.registered.get(t).forEach(function (t) {\n            o = o.then(function () {\n              return N(t.fn, t.ctx).apply(void 0, e);\n            });\n          }), o.catch(function (r) {\n            n.logger.debug(\"Hook error [\" + t + \"]\"), n.logger.error(r);\n          });\n        }\n        return Promise.resolve();\n      }, r.clear = function () {\n        var t = this;\n        this.all.forEach(function (n) {\n          delete t[n];\n        }), this.init();\n      }, r.help = function () {\n        this.logger.info(\"Available hooks: \" + this.all.join(\",\"));\n        var t = [];\n        this.registered.forEach(function (n, r) {\n          return t.push(r);\n        }), this.logger.info(\"Registered hooks: \" + t.join(\",\"));\n      }, n;\n    }(h))(),\n    z = function () {\n      function t(t) {\n        if (this.P = [], \"boolean\" == typeof t) this.g = t;else {\n          var n = Array.isArray(t) ? t : [t];\n          this.P = n.map(function (t) {\n            return $(t);\n          });\n        }\n      }\n      return t.prototype.checkHref = function (t) {\n        if (\"boolean\" == typeof this.g) return this.g;\n        var n = U(t).path;\n        return this.P.some(function (t) {\n          return null !== t.exec(n);\n        });\n      }, t;\n    }(),\n    G = function (t) {\n      function n(n) {\n        var r;\n        return (r = t.call(this, n) || this).k = new Map(), r;\n      }\n      e(n, t);\n      var i = n.prototype;\n      return i.set = function (t, n, r) {\n        return this.k.set(t, {\n          action: r,\n          request: n\n        }), {\n          action: r,\n          request: n\n        };\n      }, i.get = function (t) {\n        return this.k.get(t);\n      }, i.getRequest = function (t) {\n        return this.k.get(t).request;\n      }, i.getAction = function (t) {\n        return this.k.get(t).action;\n      }, i.has = function (t) {\n        return !this.checkHref(t) && this.k.has(t);\n      }, i.delete = function (t) {\n        return this.k.delete(t);\n      }, i.update = function (t, n) {\n        var e = r({}, this.k.get(t), {}, n);\n        return this.k.set(t, e), e;\n      }, n;\n    }(z),\n    Q = function () {\n      return !window.history.pushState;\n    },\n    W = function (t) {\n      return !t.el || !t.href;\n    },\n    J = function (t) {\n      var n = t.event;\n      return n.which > 1 || n.metaKey || n.ctrlKey || n.shiftKey || n.altKey;\n    },\n    K = function (t) {\n      var n = t.el;\n      return n.hasAttribute(\"target\") && \"_blank\" === n.target;\n    },\n    V = function (t) {\n      var n = t.el;\n      return void 0 !== n.protocol && window.location.protocol !== n.protocol || void 0 !== n.hostname && window.location.hostname !== n.hostname;\n    },\n    Y = function (t) {\n      var n = t.el;\n      return void 0 !== n.port && B() !== B(n.href);\n    },\n    Z = function (t) {\n      var n = t.el;\n      return n.getAttribute && \"string\" == typeof n.getAttribute(\"download\");\n    },\n    tt = function (t) {\n      return t.el.hasAttribute(S.prefix + \"-\" + S.prevent);\n    },\n    nt = function (t) {\n      return Boolean(t.el.closest(\"[\" + S.prefix + \"-\" + S.prevent + '=\"all\"]'));\n    },\n    rt = function (t) {\n      var n = t.href;\n      return F(n) === F() && B(n) === B();\n    },\n    et = function (t) {\n      function n(n) {\n        var r;\n        return (r = t.call(this, n) || this).suite = [], r.tests = new Map(), r.init(), r;\n      }\n      e(n, t);\n      var r = n.prototype;\n      return r.init = function () {\n        this.add(\"pushState\", Q), this.add(\"exists\", W), this.add(\"newTab\", J), this.add(\"blank\", K), this.add(\"corsDomain\", V), this.add(\"corsPort\", Y), this.add(\"download\", Z), this.add(\"preventSelf\", tt), this.add(\"preventAll\", nt), this.add(\"sameUrl\", rt, !1);\n      }, r.add = function (t, n, r) {\n        void 0 === r && (r = !0), this.tests.set(t, n), r && this.suite.push(t);\n      }, r.run = function (t, n, r, e) {\n        return this.tests.get(t)({\n          el: n,\n          event: r,\n          href: e\n        });\n      }, r.checkLink = function (t, n, r) {\n        var e = this;\n        return this.suite.some(function (i) {\n          return e.run(i, t, n, r);\n        });\n      }, n;\n    }(z),\n    it = function (t) {\n      function n(r, e) {\n        var i;\n        void 0 === e && (e = \"Barba error\");\n        for (var o = arguments.length, u = new Array(o > 2 ? o - 2 : 0), f = 2; f < o; f++) u[f - 2] = arguments[f];\n        return (i = t.call.apply(t, [this].concat(u)) || this).error = r, i.label = e, Error.captureStackTrace && Error.captureStackTrace(function (t) {\n          if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return t;\n        }(i), n), i.name = \"BarbaError\", i;\n      }\n      return e(n, t), n;\n    }(f(Error)),\n    ot = function () {\n      function t(t) {\n        void 0 === t && (t = []), this.logger = new l(\"@barba/core\"), this.all = [], this.page = [], this.once = [], this.A = [{\n          name: \"namespace\",\n          type: \"strings\"\n        }, {\n          name: \"custom\",\n          type: \"function\"\n        }], t && (this.all = this.all.concat(t)), this.update();\n      }\n      var n = t.prototype;\n      return n.add = function (t, n) {\n        switch (t) {\n          case \"rule\":\n            this.A.splice(n.position || 0, 0, n.value);\n            break;\n          case \"transition\":\n          default:\n            this.all.push(n);\n        }\n        this.update();\n      }, n.resolve = function (t, n) {\n        var r = this;\n        void 0 === n && (n = {});\n        var e = n.once ? this.once : this.page;\n        e = e.filter(n.self ? function (t) {\n          return t.name && \"self\" === t.name;\n        } : function (t) {\n          return !t.name || \"self\" !== t.name;\n        });\n        var i = new Map(),\n          o = e.find(function (e) {\n            var o = !0,\n              u = {};\n            return !(!n.self || \"self\" !== e.name) || (r.A.reverse().forEach(function (n) {\n              o && (o = r.R(e, n, t, u), e.from && e.to && (o = r.R(e, n, t, u, \"from\") && r.R(e, n, t, u, \"to\")), e.from && !e.to && (o = r.R(e, n, t, u, \"from\")), !e.from && e.to && (o = r.R(e, n, t, u, \"to\")));\n            }), i.set(e, u), o);\n          }),\n          u = i.get(o),\n          f = [];\n        if (f.push(n.once ? \"once\" : \"page\"), n.self && f.push(\"self\"), u) {\n          var s,\n            c = [o];\n          Object.keys(u).length > 0 && c.push(u), (s = this.logger).info.apply(s, [\"Transition found [\" + f.join(\",\") + \"]\"].concat(c));\n        } else this.logger.info(\"No transition found [\" + f.join(\",\") + \"]\");\n        return o;\n      }, n.update = function () {\n        var t = this;\n        this.all = this.all.map(function (n) {\n          return t.T(n);\n        }).sort(function (t, n) {\n          return t.priority - n.priority;\n        }).reverse().map(function (t) {\n          return delete t.priority, t;\n        }), this.page = this.all.filter(function (t) {\n          return void 0 !== t.leave || void 0 !== t.enter;\n        }), this.once = this.all.filter(function (t) {\n          return void 0 !== t.once;\n        });\n      }, n.R = function (t, n, r, e, i) {\n        var o = !0,\n          u = !1,\n          f = t,\n          s = n.name,\n          c = s,\n          a = s,\n          h = s,\n          v = i ? f[i] : f,\n          l = \"to\" === i ? r.next : r.current;\n        if (i ? v && v[s] : v[s]) {\n          switch (n.type) {\n            case \"strings\":\n            default:\n              var d = Array.isArray(v[c]) ? v[c] : [v[c]];\n              l[c] && -1 !== d.indexOf(l[c]) && (u = !0), -1 === d.indexOf(l[c]) && (o = !1);\n              break;\n            case \"object\":\n              var m = Array.isArray(v[a]) ? v[a] : [v[a]];\n              l[a] ? (l[a].name && -1 !== m.indexOf(l[a].name) && (u = !0), -1 === m.indexOf(l[a].name) && (o = !1)) : o = !1;\n              break;\n            case \"function\":\n              v[h](r) ? u = !0 : o = !1;\n          }\n          u && (i ? (e[i] = e[i] || {}, e[i][s] = f[i][s]) : e[s] = f[s]);\n        }\n        return o;\n      }, n.O = function (t, n, r) {\n        var e = 0;\n        return (t[n] || t.from && t.from[n] || t.to && t.to[n]) && (e += Math.pow(10, r), t.from && t.from[n] && (e += 1), t.to && t.to[n] && (e += 2)), e;\n      }, n.T = function (t) {\n        var n = this;\n        t.priority = 0;\n        var r = 0;\n        return this.A.forEach(function (e, i) {\n          r += n.O(t, e.name, i + 1);\n        }), t.priority = r, t;\n      }, t;\n    }(),\n    ut = function () {\n      function t(t) {\n        void 0 === t && (t = []), this.logger = new l(\"@barba/core\"), this.S = !1, this.store = new ot(t);\n      }\n      var r = t.prototype;\n      return r.get = function (t, n) {\n        return this.store.resolve(t, n);\n      }, r.doOnce = function (t) {\n        var n = t.data,\n          r = t.transition;\n        try {\n          var e = function () {\n              i.S = !1;\n            },\n            i = this,\n            o = r || {};\n          i.S = !0;\n          var u = s(function () {\n            return Promise.resolve(i.j(\"beforeOnce\", n, o)).then(function () {\n              return Promise.resolve(i.once(n, o)).then(function () {\n                return Promise.resolve(i.j(\"afterOnce\", n, o)).then(function () {});\n              });\n            });\n          }, function (t) {\n            i.S = !1, i.logger.debug(\"Transition error [before/after/once]\"), i.logger.error(t);\n          });\n          return Promise.resolve(u && u.then ? u.then(e) : e());\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, r.doPage = function (t) {\n        var n = t.data,\n          r = t.transition,\n          e = t.page,\n          i = t.wrapper;\n        try {\n          var o = function (t) {\n              if (u) return t;\n              f.S = !1;\n            },\n            u = !1,\n            f = this,\n            c = r || {},\n            a = !0 === c.sync || !1;\n          f.S = !0;\n          var h = s(function () {\n            function t() {\n              return Promise.resolve(f.j(\"before\", n, c)).then(function () {\n                var t = !1;\n                function r(r) {\n                  return t ? r : Promise.resolve(f.remove(n)).then(function () {\n                    return Promise.resolve(f.j(\"after\", n, c)).then(function () {});\n                  });\n                }\n                var o = function () {\n                  if (a) return s(function () {\n                    return Promise.resolve(f.add(n, i)).then(function () {\n                      return Promise.resolve(f.j(\"beforeLeave\", n, c)).then(function () {\n                        return Promise.resolve(f.j(\"beforeEnter\", n, c)).then(function () {\n                          return Promise.resolve(Promise.all([f.leave(n, c), f.enter(n, c)])).then(function () {\n                            return Promise.resolve(f.j(\"afterLeave\", n, c)).then(function () {\n                              return Promise.resolve(f.j(\"afterEnter\", n, c)).then(function () {});\n                            });\n                          });\n                        });\n                      });\n                    });\n                  }, function (t) {\n                    if (f.M(t)) throw new it(t, \"Transition error [sync]\");\n                  });\n                  var r = function (r) {\n                      return t ? r : s(function () {\n                        var t = function () {\n                          if (!1 !== o) return Promise.resolve(f.add(n, i)).then(function () {\n                            return Promise.resolve(f.j(\"beforeEnter\", n, c)).then(function () {\n                              return Promise.resolve(f.enter(n, c, o)).then(function () {\n                                return Promise.resolve(f.j(\"afterEnter\", n, c)).then(function () {});\n                              });\n                            });\n                          });\n                        }();\n                        if (t && t.then) return t.then(function () {});\n                      }, function (t) {\n                        if (f.M(t)) throw new it(t, \"Transition error [before/after/enter]\");\n                      });\n                    },\n                    o = !1,\n                    u = s(function () {\n                      return Promise.resolve(f.j(\"beforeLeave\", n, c)).then(function () {\n                        return Promise.resolve(Promise.all([f.leave(n, c), L(e, n)]).then(function (t) {\n                          return t[0];\n                        })).then(function (t) {\n                          return o = t, Promise.resolve(f.j(\"afterLeave\", n, c)).then(function () {});\n                        });\n                      });\n                    }, function (t) {\n                      if (f.M(t)) throw new it(t, \"Transition error [before/after/leave]\");\n                    });\n                  return u && u.then ? u.then(r) : r(u);\n                }();\n                return o && o.then ? o.then(r) : r(o);\n              });\n            }\n            var r = function () {\n              if (a) return Promise.resolve(L(e, n)).then(function () {});\n            }();\n            return r && r.then ? r.then(t) : t();\n          }, function (t) {\n            if (f.S = !1, t.name && \"BarbaError\" === t.name) throw f.logger.debug(t.label), f.logger.error(t.error), t;\n            throw f.logger.debug(\"Transition error [page]\"), f.logger.error(t), t;\n          });\n          return Promise.resolve(h && h.then ? h.then(o) : o(h));\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, r.once = function (t, n) {\n        try {\n          return Promise.resolve(X.do(\"once\", t, n)).then(function () {\n            return n.once ? N(n.once, n)(t) : Promise.resolve();\n          });\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, r.leave = function (t, n) {\n        try {\n          return Promise.resolve(X.do(\"leave\", t, n)).then(function () {\n            return n.leave ? N(n.leave, n)(t) : Promise.resolve();\n          });\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, r.enter = function (t, n, r) {\n        try {\n          return Promise.resolve(X.do(\"enter\", t, n)).then(function () {\n            return n.enter ? N(n.enter, n)(t, r) : Promise.resolve();\n          });\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, r.add = function (t, n) {\n        try {\n          return j.addContainer(t.next.container, n), X.do(\"nextAdded\", t), Promise.resolve();\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, r.remove = function (t) {\n        try {\n          return j.removeContainer(t.current.container), X.do(\"currentRemoved\", t), Promise.resolve();\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, r.M = function (t) {\n        return t.message ? !/Timeout error|Fetch error/.test(t.message) : !t.status;\n      }, r.j = function (t, n, r) {\n        try {\n          return Promise.resolve(X.do(t, n, r)).then(function () {\n            return r[t] ? N(r[t], r)(n) : Promise.resolve();\n          });\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, n(t, [{\n        key: \"isRunning\",\n        get: function () {\n          return this.S;\n        },\n        set: function (t) {\n          this.S = t;\n        }\n      }, {\n        key: \"hasOnce\",\n        get: function () {\n          return this.store.once.length > 0;\n        }\n      }, {\n        key: \"hasSelf\",\n        get: function () {\n          return this.store.all.some(function (t) {\n            return \"self\" === t.name;\n          });\n        }\n      }, {\n        key: \"shouldWait\",\n        get: function () {\n          return this.store.all.some(function (t) {\n            return t.to && !t.to.route || t.sync;\n          });\n        }\n      }]), t;\n    }(),\n    ft = function () {\n      function t(t) {\n        var n = this;\n        this.names = [\"beforeLeave\", \"afterLeave\", \"beforeEnter\", \"afterEnter\"], this.byNamespace = new Map(), 0 !== t.length && (t.forEach(function (t) {\n          n.byNamespace.set(t.namespace, t);\n        }), this.names.forEach(function (t) {\n          X[t](n.L(t));\n        }));\n      }\n      return t.prototype.L = function (t) {\n        var n = this;\n        return function (r) {\n          var e = t.match(/enter/i) ? r.next : r.current,\n            i = n.byNamespace.get(e.namespace);\n          return i && i[t] ? N(i[t], i)(r) : Promise.resolve();\n        };\n      }, t;\n    }();\n  Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (t) {\n    var n = this;\n    do {\n      if (n.matches(t)) return n;\n      n = n.parentElement || n.parentNode;\n    } while (null !== n && 1 === n.nodeType);\n    return null;\n  });\n  var st = {\n    container: null,\n    html: \"\",\n    namespace: \"\",\n    url: {\n      hash: \"\",\n      href: \"\",\n      path: \"\",\n      port: null,\n      query: {}\n    }\n  };\n  return new (function () {\n    function t() {\n      this.version = a, this.schemaPage = st, this.Logger = l, this.logger = new l(\"@barba/core\"), this.plugins = [], this.hooks = X, this.dom = j, this.helpers = _, this.history = M, this.request = I, this.url = H;\n    }\n    var e = t.prototype;\n    return e.use = function (t, n) {\n      var r = this.plugins;\n      r.indexOf(t) > -1 ? this.logger.warn(\"Plugin [\" + t.name + \"] already installed.\") : \"function\" == typeof t.install ? (t.install(this, n), r.push(t)) : this.logger.warn(\"Plugin [\" + t.name + '] has no \"install\" method.');\n    }, e.init = function (t) {\n      var n = void 0 === t ? {} : t,\n        e = n.transitions,\n        i = void 0 === e ? [] : e,\n        o = n.views,\n        u = void 0 === o ? [] : o,\n        f = n.schema,\n        s = void 0 === f ? S : f,\n        c = n.requestError,\n        a = n.timeout,\n        h = void 0 === a ? 2e3 : a,\n        v = n.cacheIgnore,\n        d = void 0 !== v && v,\n        m = n.prefetchIgnore,\n        p = void 0 !== m && m,\n        w = n.preventRunning,\n        b = void 0 !== w && w,\n        y = n.prevent,\n        P = void 0 === y ? null : y,\n        g = n.debug,\n        E = n.logLevel;\n      if (l.setLevel(!0 === (void 0 !== g && g) ? \"debug\" : void 0 === E ? \"off\" : E), this.logger.info(this.version), Object.keys(s).forEach(function (t) {\n        S[t] && (S[t] = s[t]);\n      }), this.$ = c, this.timeout = h, this.cacheIgnore = d, this.prefetchIgnore = p, this.preventRunning = b, this._ = this.dom.getWrapper(), !this._) throw new Error(\"[@barba/core] No Barba wrapper found\");\n      this._.setAttribute(\"aria-live\", \"polite\"), this.q();\n      var x = this.data.current;\n      if (!x.container) throw new Error(\"[@barba/core] No Barba container found\");\n      if (this.cache = new G(d), this.prevent = new et(p), this.transitions = new ut(i), this.views = new ft(u), null !== P) {\n        if (\"function\" != typeof P) throw new Error(\"[@barba/core] Prevent should be a function\");\n        this.prevent.add(\"preventCustom\", P);\n      }\n      this.history.init(x.url.href, x.namespace), this.B = this.B.bind(this), this.U = this.U.bind(this), this.D = this.D.bind(this), this.F(), this.plugins.forEach(function (t) {\n        return t.init();\n      });\n      var k = this.data;\n      k.trigger = \"barba\", k.next = k.current, k.current = r({}, this.schemaPage), this.hooks.do(\"ready\", k), this.once(k), this.q();\n    }, e.destroy = function () {\n      this.q(), this.H(), this.history.clear(), this.hooks.clear(), this.plugins = [];\n    }, e.force = function (t) {\n      window.location.assign(t);\n    }, e.go = function (t, n, r) {\n      var e;\n      if (void 0 === n && (n = \"barba\"), this.transitions.isRunning) this.force(t);else if (!(e = \"popstate\" === n ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t) : this.prevent.run(\"sameUrl\", null, null, t)) || this.transitions.hasSelf) return n = this.history.change(t, n, r), r && (r.stopPropagation(), r.preventDefault()), this.page(t, n, e);\n    }, e.once = function (t) {\n      try {\n        var n = this;\n        return Promise.resolve(n.hooks.do(\"beforeEnter\", t)).then(function () {\n          function r() {\n            return Promise.resolve(n.hooks.do(\"afterEnter\", t)).then(function () {});\n          }\n          var e = function () {\n            if (n.transitions.hasOnce) {\n              var r = n.transitions.get(t, {\n                once: !0\n              });\n              return Promise.resolve(n.transitions.doOnce({\n                transition: r,\n                data: t\n              })).then(function () {});\n            }\n          }();\n          return e && e.then ? e.then(r) : r();\n        });\n      } catch (t) {\n        return Promise.reject(t);\n      }\n    }, e.page = function (t, n, e) {\n      try {\n        var i = function () {\n            var t = o.data;\n            return Promise.resolve(o.hooks.do(\"page\", t)).then(function () {\n              var n = s(function () {\n                var n = o.transitions.get(t, {\n                  once: !1,\n                  self: e\n                });\n                return Promise.resolve(o.transitions.doPage({\n                  data: t,\n                  page: u,\n                  transition: n,\n                  wrapper: o._\n                })).then(function () {\n                  o.q();\n                });\n              }, function () {\n                0 === l.getLevel() && o.force(t.current.url.href);\n              });\n              if (n && n.then) return n.then(function () {});\n            });\n          },\n          o = this;\n        o.data.next.url = r({\n          href: t\n        }, o.url.parse(t)), o.data.trigger = n;\n        var u = o.cache.has(t) ? o.cache.update(t, {\n            action: \"click\"\n          }).request : o.cache.set(t, o.request(t, o.timeout, o.onRequestError.bind(o, n)), \"click\").request,\n          f = function () {\n            if (o.transitions.shouldWait) return Promise.resolve(L(u, o.data)).then(function () {});\n          }();\n        return Promise.resolve(f && f.then ? f.then(i) : i());\n      } catch (t) {\n        return Promise.reject(t);\n      }\n    }, e.onRequestError = function (t) {\n      this.transitions.isRunning = !1;\n      for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), e = 1; e < n; e++) r[e - 1] = arguments[e];\n      var i = r[0],\n        o = r[1],\n        u = this.cache.getAction(i);\n      return this.cache.delete(i), !(this.$ && !1 === this.$(t, u, i, o) || (\"click\" === u && this.force(i), 1));\n    }, e.prefetch = function (t) {\n      var n = this;\n      this.cache.has(t) || this.cache.set(t, this.request(t, this.timeout, this.onRequestError.bind(this, \"barba\")).catch(function (t) {\n        n.logger.error(t);\n      }), \"prefetch\");\n    }, e.F = function () {\n      !0 !== this.prefetchIgnore && (document.addEventListener(\"mouseover\", this.B), document.addEventListener(\"touchstart\", this.B)), document.addEventListener(\"click\", this.U), window.addEventListener(\"popstate\", this.D);\n    }, e.H = function () {\n      !0 !== this.prefetchIgnore && (document.removeEventListener(\"mouseover\", this.B), document.removeEventListener(\"touchstart\", this.B)), document.removeEventListener(\"click\", this.U), window.removeEventListener(\"popstate\", this.D);\n    }, e.B = function (t) {\n      var n = this,\n        r = this.I(t);\n      if (r) {\n        var e = this.dom.getHref(r);\n        this.prevent.checkHref(e) || this.cache.has(e) || this.cache.set(e, this.request(e, this.timeout, this.onRequestError.bind(this, r)).catch(function (t) {\n          n.logger.error(t);\n        }), \"enter\");\n      }\n    }, e.U = function (t) {\n      var n = this.I(t);\n      if (n) return this.transitions.isRunning && this.preventRunning ? (t.preventDefault(), void t.stopPropagation()) : void this.go(this.dom.getHref(n), n, t);\n    }, e.D = function (t) {\n      this.go(this.url.getHref(), \"popstate\", t);\n    }, e.I = function (t) {\n      for (var n = t.target; n && !this.dom.getHref(n);) n = n.parentNode;\n      if (n && !this.prevent.checkLink(n, t, this.dom.getHref(n))) return n;\n    }, e.q = function () {\n      var t = this.url.getHref(),\n        n = {\n          container: this.dom.getContainer(),\n          html: this.dom.getHtml(),\n          namespace: this.dom.getNamespace(),\n          url: r({\n            href: t\n          }, this.url.parse(t))\n        };\n      this.C = {\n        current: n,\n        next: r({}, this.schemaPage),\n        trigger: void 0\n      }, this.hooks.do(\"reset\", this.data);\n    }, n(t, [{\n      key: \"data\",\n      get: function () {\n        return this.C;\n      }\n    }, {\n      key: \"wrapper\",\n      get: function () {\n        return this._;\n      }\n    }]), t;\n  }())();\n});","map":{"version":3,"names":["s","t","n","r","then","Symbol","iterator","asyncIterator","c","a","h","off","error","warning","info","debug","v","l","getLevel","setLevel","prototype","arguments","length","Array","i","console","warn","log","e","apply","concat","d","O","m","E","p","g","w","x","b","T","y","P","RegExp","join","o","u","f","delimiter","whitelist","exec","index","slice","indexOf","push","name","prefix","optional","repeat","pattern","A","k","substr","decode","decodeURIComponent","split","map","path","params","R","encode","encodeURIComponent","validate","isArray","TypeError","test","String","replace","sensitive","strict","start","end","endsWith","source","match","regexpToFunction","parse","compile","tokensToFunction","tokensToRegExp","S","container","history","namespace","prevent","wrapper","j","DOMParser","toString","outerHTML","toDocument","parseFromString","toElement","document","createElement","innerHTML","getHtml","documentElement","getWrapper","querySelector","getContainer","removeContainer","body","contains","parentNode","removeChild","addContainer","appendChild","getNamespace","getAttribute","getHref","tagName","toLowerCase","href","resolveUrl","baseVal","Error","getElementsByTagName","insertBefore","firstChild","nextSibling","M","init","ns","scroll","window","scrollX","scrollY","url","from","states","replaceState","change","state","add","size","pushState","update","get","set","remove","splice","pop","clear","hasAttribute","Math","abs","key","L","next","html","Promise","resolve","title","reject","$","_","__proto__","nextTick","ptr","requestAnimationFrame","pathToRegexp","q","getOrigin","location","origin","B","getPort","U","port","substring","parseInt","D","hash","query","parseQuery","reduce","F","clean","H","getPath","I","XMLHttpRequest","onreadystatechange","readyState","DONE","status","responseText","statusText","ontimeout","onerror","open","timeout","setRequestHeader","send","C","N","async","X","call","logger","all","registered","Map","forEach","has","Set","ctx","fn","do","catch","help","z","checkHref","some","G","action","request","getRequest","getAction","delete","Q","W","exists","el","J","newTab","event","which","metaKey","ctrlKey","shiftKey","altKey","K","blank","target","V","corsDomain","protocol","hostname","Y","corsPort","Z","download","tt","preventSelf","nt","preventAll","Boolean","closest","rt","sameUrl","et","suite","tests","run","checkLink","it","label","captureStackTrace","ReferenceError","ot","page","once","type","position","value","filter","self","find","reverse","to","Object","keys","sort","priority","leave","enter","current","pow","ut","store","doOnce","data","transition","doPage","sync","message","route","ft","names","byNamespace","Element","matches","msMatchesSelector","webkitMatchesSelector","parentElement","nodeType","st","version","schemaPage","Logger","plugins","hooks","dom","helpers","use","install","transitions","views","schema","requestError","cacheIgnore","prefetchIgnore","preventRunning","logLevel","setAttribute","cache","bind","trigger","destroy","force","assign","go","isRunning","hasSelf","stopPropagation","preventDefault","hasOnce","onRequestError","shouldWait","prefetch","addEventListener","removeEventListener"],"sources":["D:\\Web Dev\\ZiegersHome\\node_modules\\node_modules\\babel-plugin-transform-async-to-promises\\helpers.js","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\modules\\Logger.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\defs\\hooks.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\node_modules\\path-to-regexp\\index.js","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\schemas\\attribute.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\utils\\dom.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\utils\\history.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\utils\\helpers.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\utils\\url.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\utils\\request.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\node_modules\\is-promise\\index.js","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\utils\\run-async.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\hooks.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\modules\\Ignore.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\modules\\Cache.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\modules\\Prevent.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\modules\\Error.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\modules\\Store.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\modules\\Transitions.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\modules\\Views.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\polyfills\\index.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\schemas\\page.ts","D:\\Web Dev\\ZiegersHome\\node_modules\\@barba\\core\\src\\core.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\n * @barba/core/modules/Logger\n * <br><br>\n * ## Logger.\n *\n * - Display informations via the console\n *\n * @module core/modules/Logger\n * @preferred\n */\n\n/***/\n\n/**\n * Log levels, all lower level messages are printed\n *\n * 0. mute\n * 1. error = `console.error()`\n * 2. warning= `console.warn()`\n * 3. info = `console.info()`\n * 4. debug = `console.log()`\n */\nexport enum LogLevels {\n  off = 0,\n  error = 1,\n  warning = 2,\n  info = 3,\n  debug = 4,\n}\n\n/**\n * Global log level\n */\nlet _level: number = LogLevels.off;\n\nexport class Logger {\n  /**\n   * Get global log level.\n   */\n  public static getLevel(): number {\n    return _level;\n  }\n\n  /**\n   * Set global log level.\n   */\n  public static setLevel(name: keyof typeof LogLevels): number {\n    _level = LogLevels[name];\n\n    return _level;\n  }\n\n  /**\n   * Log \"prefix\".\n   */\n  private _source: string;\n\n  /**\n   * Creates an instance of Logger.\n   */\n  constructor(source: string) {\n    this._source = source;\n  }\n\n  /**\n   * Permanent, unremovable log.\n   */\n  // public print(...objects: any[]): void {\n  //   this._log(console.info, LogLevels.off, objects);\n  // }\n\n  /**\n   * Error log.\n   */\n  public error(...objects: any[]): void {\n    this._log(console.error, LogLevels.error, objects);\n  }\n\n  /**\n   * Warn log.\n   */\n  public warn(...objects: any[]): void {\n    this._log(console.warn, LogLevels.warning, objects);\n  }\n\n  /**\n   * Info log.\n   */\n  public info(...objects: any[]): void {\n    this._log(console.info, LogLevels.info, objects);\n  }\n\n  /**\n   * Debug log.\n   */\n  public debug(...objects: any[]): void {\n    this._log(console.log, LogLevels.debug, objects);\n  }\n\n  /**\n   * Internal logger.\n   */\n  private _log(fn: () => void, level: number, objects: any[]): void {\n    if (level <= Logger.getLevel()) {\n      fn.apply(console, ([`[${this._source}] `].concat(objects) as unknown) as [\n\n      ]);\n    }\n  }\n}\n","/**\n * @module typings/core\n */\nimport { ITransitionData, ITransitionPage, IViewData } from './index';\n\nexport type HooksBarba =\n  | 'ready'\n  | 'page'\n  | 'reset'\n  | 'currentAdded'\n  | 'currentRemoved'\n  | 'nextAdded'\n  | 'nextRemoved';\n\nexport type HooksOnce = 'beforeOnce' | 'once' | 'afterOnce';\n\nexport type HooksPage =\n  | 'before'\n  | 'beforeLeave'\n  | 'leave'\n  | 'afterLeave'\n  | 'beforeEnter'\n  | 'enter'\n  | 'afterEnter'\n  | 'after';\n\nexport type HooksBefore = 'beforeOnce' | 'beforeLeave' | 'beforeEnter';\nexport type HooksAfter = 'afterOnce' | 'afterLeave' | 'afterEnter';\n\nexport type HooksTransition = HooksOnce | HooksPage;\nexport type HooksView = HooksBefore | HooksAfter;\nexport type HooksAll = HooksBarba | HooksTransition;\n\n// Allow optional \"dynamically created\" hooks\nexport type HooksTransitionMap = { [key in HooksTransition]?: any };\n\nexport type HookFunction = (\n  data?: ITransitionData | IViewData,\n  t?: ITransitionPage\n) => Promise<void> | void;\n\nexport class HookMethods {\n  public before: (fn: HookFunction, ctx?: any) => void;\n  public beforeLeave: (fn: HookFunction, ctx?: any) => void;\n  public leave: (fn: HookFunction, ctx?: any) => void;\n  public afterLeave: (fn: HookFunction, ctx?: any) => void;\n  public beforeEnter: (fn: HookFunction, ctx?: any) => void;\n  public enter: (fn: HookFunction, ctx?: any) => void;\n  public afterEnter: (fn: HookFunction, ctx?: any) => void;\n  public after: (fn: HookFunction, ctx?: any) => void;\n}\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.match = match\nmodule.exports.regexpToFunction = regexpToFunction\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var whitelist = (options && options.whitelist) || undefined\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n      var c = path[k]\n      var matches = whitelist ? whitelist.indexOf(c) > -1 : true\n\n      if (matches) {\n        prev = c\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var pattern = capture || group\n    var delimiter = prev || defaultDelimiter\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: pattern\n        ? escapeGroup(pattern)\n        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match (str, options) {\n  var keys = []\n  var re = pathToRegexp(str, keys, options)\n  return regexpToFunction(re, keys)\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction (re, keys) {\n  return function (pathname, options) {\n    var m = re.exec(pathname)\n    if (!m) return false\n\n    var path = m[0]\n    var index = m.index\n    var params = {}\n    var decode = (options && options.decode) || decodeURIComponent\n\n    for (var i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue\n\n      var key = keys[i - 1]\n\n      if (key.repeat) {\n        params[key.name] = m[i].split(key.delimiter).map(function (value) {\n          return decode(value, key)\n        })\n      } else {\n        params[key.name] = decode(m[i], key)\n      }\n    }\n\n    return { path: path, index: index, params: params }\n  }\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n    var validate = options ? options.validate !== false : true\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) continue\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = options.delimiter || DEFAULT_DELIMITER\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + escapeString(delimiter) + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    var endToken = tokens[tokens.length - 1]\n    var isEndDelimited = typeof endToken === 'string'\n      ? endToken[endToken.length - 1] === delimiter\n      : endToken === undefined\n\n    if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/**\n * @barba/core/schemas\n * <br><br>\n * ## Schemas description.\n *\n * @module core/schemas\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { ISchemaAttribute } from '../defs';\n\n/**\n * See [[ISchemaAttribute]]\n */\nexport const schemaAttribute: ISchemaAttribute = {\n  container: 'container',\n  history: 'history',\n  namespace: 'namespace',\n  prefix: 'data-barba',\n  prevent: 'prevent',\n  wrapper: 'wrapper',\n};\n","/**\n * @barba/core/utils/dom\n * <br><br>\n * ## Dom utils\n *\n * - Access DOM contents\n * - DOM vs string conversions\n *\n * @module core/utils/dom\n * @preferred\n */\n\n/***/\n\nimport path from 'path';\n\n// Definitions\nimport { ISchemaAttribute, Link, Scope, Wrapper } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\nexport class Dom {\n  private _attr: ISchemaAttribute = schemaAttribute;\n  private _parser: DOMParser = new DOMParser();\n\n  /**\n   * Convert HTMLDocument to string.\n   */\n  public toString(el: HTMLElement): string {\n    return el.outerHTML;\n  }\n\n  /**\n   * Parse HTML string to HTMLDocument.\n   */\n  // see https://github.com/barbajs/barba/issues/362\n  // Seems that using DOMParser.parseFromString causes this issue.\n  public toDocument(htmlString: string): HTMLDocument {\n    return this._parser.parseFromString(htmlString, 'text/html');\n  }\n\n  /**\n   * Parse HTML string to DIVElement.\n   *\n   * DOMParser.parseFromString fails with img[srcset] on iOS.\n   * see https://github.com/barbajs/barba/issues/362\n   */\n  public toElement(htmlString: string): HTMLDivElement {\n    const div = document.createElement('div');\n\n    div.innerHTML = htmlString;\n    return div;\n  }\n\n  /**\n   * Get HTML content.\n   */\n  public getHtml(doc: HTMLDocument = document): string {\n    return this.toString(doc.documentElement);\n  }\n\n  /**\n   * Get full document content.\n   */\n  // getDocument(el = document.documentElement) {\n  //   return this.toStr(el);\n  // },\n\n  /**\n   * Get `[data-barba=\"wrapper\"]`.\n   */\n  public getWrapper(scope: Scope = document): Wrapper {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.wrapper}\"]`\n    );\n  }\n\n  /**\n   * Get `[data-barba=\"container\"]`.\n   */\n  public getContainer(scope: Scope = document): HTMLElement | null {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.container}\"]`\n    );\n  }\n\n  /**\n   * Remove container and store next sibling (if applicable).\n   */\n  public removeContainer(container: HTMLElement) {\n    if (document.body.contains(container)) {\n      container.parentNode.removeChild(container);\n    }\n  }\n\n  /**\n   * Add container before next sibling or at the end of the wrapper.\n   */\n  public addContainer(container: HTMLElement, wrapper: HTMLElement) {\n    const existingContainer = this.getContainer();\n\n    if (existingContainer) {\n      this._insertAfter(container, existingContainer);\n    } else {\n      wrapper.appendChild(container);\n    }\n  }\n\n  /**\n   * Get `[data-barba-namespace]`.\n   */\n  public getNamespace(scope: Scope = document): string | null {\n    const ns = scope.querySelector(\n      `[${this._attr.prefix}-${this._attr.namespace}]`\n    );\n\n    return ns\n      ? ns.getAttribute(`${this._attr.prefix}-${this._attr.namespace}`)\n      : null;\n  }\n\n  /**\n   * Get URL from `href` value.\n   */\n  public getHref(el: Link): string | null {\n    // HTML tagName is UPPERCASE, xhtml tagName keeps existing case.\n    if (el.tagName && el.tagName.toLowerCase() === 'a') {\n      // HTMLAnchorElement, full URL available\n      if (typeof el.href === 'string') {\n        return el.href;\n      }\n\n      // Probably a SVGAElement\n      const href = el.getAttribute('href') || el.getAttribute('xlink:href');\n\n      /* istanbul ignore else */\n      if (href) {\n        // When link comes from SVG, `href` returns an object, not a string.\n        const attr: string =\n          ((href as unknown) as SVGAnimatedString).baseVal || href;\n\n        return this.resolveUrl(attr);\n      }\n    }\n    return null;\n  }\n\n  // Copyright 2014 Simon Lydell\n  // X11 (MIT) Licensed. (See LICENSE\n  // https://github.com/lydell/resolve-url/blob/master/resolve-url.js\n  /* istanbul ignore next */\n  public resolveUrl(...urls: string[]) {\n    const numUrls = urls.length;\n\n    if (numUrls === 0) {\n      throw new Error('resolveUrl requires at least one argument; got none.');\n    }\n\n    const base = document.createElement('base');\n    base.href = arguments[0];\n\n    if (numUrls === 1) {\n      return base.href;\n    }\n\n    const head = document.getElementsByTagName('head')[0];\n    head.insertBefore(base, head.firstChild);\n\n    const a = document.createElement('a');\n    let resolved;\n\n    for (let index = 1; index < numUrls; index++) {\n      a.href = arguments[index];\n      resolved = a.href;\n      base.href = resolved;\n    }\n\n    head.removeChild(base);\n\n    return resolved;\n  }\n\n  /**\n   * Insert node after another node.\n   */\n  private _insertAfter(newNode: Node, referenceNode: Node) {\n    referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n  }\n}\n\nconst dom = new Dom();\n\nexport { dom };\n","import { HistoryAction, LinkEvent, Trigger } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\n/**\n * @barba/core/utils/history\n * <br><br>\n * ## History manager.\n *\n * - Keep track of the navigation history\n *\n * @module core/utils/history\n * @preferred\n */\n\n/**\n * State item.\n *\n * @property from\n * @property index\n */\ninterface IHistoryItem {\n  /** origin */\n  from: string;\n  /** index */\n  index: number;\n  /** states */\n  states: IStateItem[];\n}\n\n/***/\ninterface ICoords {\n  x: number;\n  y: number;\n}\n\n/**\n * History item.\n *\n * @property namespace\n * @property scroll\n * @property URL\n */\ninterface IStateItem {\n  /** namespace */\n  ns: string | undefined;\n  /** Scroll position */\n  scroll: ICoords;\n  /** URL */\n  url: string;\n}\n\nexport class History {\n  private _session: string;\n  private _states: IStateItem[] = [];\n  private _pointer = -1;\n\n  /**\n   * Init with first state.\n   */\n  public init(url: string, ns: string): void {\n    this._session = 'barba';\n    const index = 0;\n\n    const state: IStateItem = {\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    this._states.push(state);\n    this._pointer = index;\n\n    const item: IHistoryItem = {\n      from: this._session,\n      index,\n      states: [...this._states],\n    };\n\n    window.history && window.history.replaceState(item, '', url);\n  }\n\n  public change(\n    url: string,\n    trigger: Trigger,\n    e?: LinkEvent | PopStateEvent\n  ): Trigger {\n    if (e && (e as PopStateEvent).state) {\n      // If popstate, move to existing state\n      // and get back/forward direction.\n      const { state }: { state: IHistoryItem } = e as PopStateEvent;\n      const { index } = state;\n      const diff = this._pointer - index;\n\n      trigger = this._getDirection(diff);\n\n      // Work with previous states\n      this.replace(state.states);\n      this._pointer = index;\n    } else {\n      // Add new state\n      this.add(url, trigger);\n    }\n\n    return trigger;\n  }\n\n  /**\n   * Add a new state.\n   */\n  public add(url: string, trigger: Trigger): void {\n    // If no state, it will be updated later.\n    const ns = 'tmp';\n    const index = this.size;\n    const action = this._getAction(trigger);\n    const state: IStateItem = {\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    this._states.push(state);\n    this._pointer = index;\n\n    const item: IHistoryItem = {\n      from: this._session,\n      index,\n      states: [...this._states],\n    };\n\n    switch (action) {\n      case 'push':\n        window.history && window.history.pushState(item, '', url);\n        break;\n      case 'replace':\n        window.history && window.history.replaceState(item, '', url);\n        break;\n      /* istanbul ignore next */\n      default:\n    }\n  }\n\n  /**\n   * Update state.\n   */\n  public update(data: any, i?: number): void {\n    const index = i || this._pointer;\n    const existing = this.get(index);\n    const state: IStateItem = {\n      ...existing,\n      ...data,\n    };\n\n    this.set(index, state);\n  }\n\n  /**\n   * Remove last state.\n   */\n  public remove(i?: number): void {\n    if (i) {\n      this._states.splice(i, 1);\n    } else {\n      this._states.pop();\n    }\n\n    this._pointer--;\n  }\n\n  /**\n   * Delete all states.\n   */\n  public clear(): void {\n    this._states = [];\n    this._pointer = -1;\n  }\n\n  /**\n   * Replace all states.\n   */\n  public replace(newStates: IStateItem[]): void {\n    this._states = newStates;\n  }\n\n  /**\n   * Get state by index.\n   */\n  public get(index: number) {\n    return this._states[index];\n  }\n\n  /**\n   * Set state by index.\n   */\n  public set(i: number, state: IStateItem) {\n    return (this._states[i] = state);\n  }\n\n  /**\n   * Get the current state.\n   */\n  get current(): IStateItem {\n    return this._states[this._pointer];\n  }\n\n  /**\n   * Get the last state (top of the history stack).\n   */\n  get state(): IStateItem {\n    return this._states[this._states.length - 1];\n  }\n\n  /**\n   * Get the previous state.\n   */\n  get previous(): IStateItem | null {\n    return this._pointer < 1 ? null : this._states[this._pointer - 1];\n  }\n\n  /**\n   * Get the state size.\n   */\n  get size(): number {\n    return this._states.length;\n  }\n\n  /**\n   * Get the history action: push vs replace\n   */\n  private _getAction(trigger: Trigger): HistoryAction {\n    let action: HistoryAction = 'push';\n\n    // Manage `data-barba-history` attribute\n    // to get the right action (push vs replace).\n    const el = trigger as HTMLAnchorElement;\n    const attr = `${schemaAttribute.prefix}-${schemaAttribute.history}`;\n\n    if (el.hasAttribute && el.hasAttribute(attr)) {\n      action = el.getAttribute(attr) as HistoryAction;\n    }\n\n    return action;\n  }\n\n  /**\n   * Get the direction of popstate change\n   */\n  private _getDirection(diff: number): Trigger {\n    // Check if \"session switch\"\n    if (Math.abs(diff) > 1) {\n      // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\n      return diff > 0 ? 'forward' : 'back';\n    } else {\n      if (diff === 0) {\n        return 'popstate';\n      } else {\n        // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\n        return diff > 0 ? 'back' : 'forward';\n      }\n    }\n  }\n}\n\nconst history = new History();\n\nexport { history };\n","/**\n * @barba/core/utils/helpers\n * <br><br>\n * ## Helpers\n *\n * - Update next page data\n *\n * @module core/utils/helpers\n * @preferred\n */\n\n/***/\n\n// Third-party\nimport ptr from 'path-to-regexp';\n// Definitions\nimport { ITransitionData } from '../defs';\n// Utils\nimport { dom } from './dom';\nimport { history } from './history';\n\n/**\n * Update `data.next`, the title and the history\n */\nexport const update = async (\n  page: Promise<string | void>,\n  data: ITransitionData\n): Promise<void> => {\n  // If not already updated\n  if (!data.next.html) {\n    const html = await page;\n    const { next } = data;\n\n    if (html) {\n      // see: https://github.com/barbajs/barba/issues/362\n      // const nextDocument = dom.toDocument(html);\n      const nextDocument = dom.toElement(html);\n\n      next.namespace = dom.getNamespace(nextDocument);\n      next.container = dom.getContainer(nextDocument);\n      // see https://github.com/barbajs/barba/issues/362\n      // next.html = dom.getHtml(nextDocument);\n      // next.html = nextDocument.innerHTML;\n      next.html = html;\n\n      // Update history namespace (not available when initially set)\n      history.update({ ns: next.namespace });\n\n      // Update title.\n      const { title } = dom.toDocument(html);\n\n      document.title = title;\n    }\n  }\n};\n\n/**\n * Next tick\n */\nexport const nextTick = () =>\n  new Promise(resolve => {\n    window.requestAnimationFrame(resolve);\n    // DEV: same result?\n    // setTimeout(resolve, 0);\n  });\n\n/**\n * Turn a route string such as `/user/:name` into a regular expression.\n *\n * Used for:\n *\n * - routes to ignore\n * - route transition resolution\n *\n * @see https://www.npmjs.com/package/path-to-regexp\n */\nconst pathToRegexp = ptr;\n\nexport { pathToRegexp };\n","/**\n * @barba/core/utils/url\n * <br><br>\n * ## URL utils.\n *\n * - Collect and structure informations from URLs\n *\n * @module core/utils/url\n */\n\n/***/\n\n// Definitions\nimport { IGenericObject, IUrlBase } from '../defs';\n\n/**\n * Get location href.\n */\nexport const getHref = () => window.location.href;\n\n/**\n * Get location origin.\n */\nexport const getOrigin = () => window.location.origin;\n\n/**\n * Get port based on URL or location.\n */\nexport const getPort = (url: string = window.location.href) => parse(url).port;\n\n/**\n * Get path from URL.\n */\nexport const getPath = (url: string = window.location.href) => parse(url).path;\n\n/**\n * Get query object from URL.\n */\n// export const getQuery = (url: string): IGenericObject => parse(url).query;\n\n/**\n * Get hash from URL.\n */\n// export const getHash = (url: string): string => parse(url).hash;\n\n/**\n * Parse URL for path, query and hash and more.\n */\nexport const parse = (url: string): IUrlBase => {\n  // Port\n  let port;\n  const matches = url.match(/:\\d+/);\n\n  if (matches === null) {\n    if (/^http/.test(url)) {\n      port = 80;\n    }\n\n    if (/^https/.test(url)) {\n      port = 443;\n    }\n  } else {\n    const portString = matches[0].substring(1);\n\n    port = parseInt(portString, 10);\n  }\n\n  // Path\n  let path = url.replace(getOrigin(), '');\n  let hash;\n  let query = {};\n\n  // Hash\n  const hashIndex = path.indexOf('#');\n\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex + 1);\n    path = path.slice(0, hashIndex);\n  }\n\n  // Query\n  const queryIndex = path.indexOf('?');\n\n  if (queryIndex >= 0) {\n    query = parseQuery(path.slice(queryIndex + 1));\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    hash,\n    path,\n    port,\n    query,\n  };\n};\n\n/**\n * Parse a query string to object.\n */\nexport const parseQuery = (str: string) =>\n  str.split('&').reduce((acc: IGenericObject, el: string) => {\n    const [key, value] = el.split('=');\n\n    acc[key] = value;\n\n    return acc;\n  }, {});\n\n/**\n * Clean URL, remove \"hash\" and/or \"trailing slash\".\n */\nexport const clean = (url: string = window.location.href) =>\n  url.replace(/(\\/#.*|\\/|#.*)$/, '');\n","/**\n * @barba/core/utils/request\n * <br><br>\n * ## Fetch pages for transitions.\n *\n * - Includes timeout\n * - Uses Fetch API\n * - Handles errors\n *\n * @module core/utils/request\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { RequestError } from '../defs';\n\n/**\n * Init a page request.\n * Fetch the page and returns a promise with the text content.\n */\nfunction request(\n  url: string,\n  ttl: number = 2e3,\n  requestError: RequestError\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (xhr.status === 200) {\n          resolve(xhr.responseText);\n        } else if (xhr.status) {\n          // HTTP code is not 200, reject with response.\n          const res = {\n            status: xhr.status,\n            statusText: xhr.statusText,\n          };\n          requestError(url, res);\n          reject(res);\n        }\n      }\n    };\n    xhr.ontimeout = () => {\n      const err = new Error(`Timeout error [${ttl}]`);\n      requestError(url, err);\n      reject(err);\n    };\n    xhr.onerror = () => {\n      const err = new Error(`Fetch error`);\n      requestError(url, err);\n      reject(err);\n    };\n\n    xhr.open('GET', url);\n    xhr.timeout = ttl;\n    xhr.setRequestHeader(\n      'Accept',\n      'text/html,application/xhtml+xml,application/xml'\n    );\n    xhr.setRequestHeader('x-barba', 'yes');\n    xhr.send();\n  });\n}\n\nexport { request };\n","module.exports = isPromise;\n\nfunction isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n","import isPromise from 'is-promise';\n\n// https://github.com/SBoudrias/run-async\n/* istanbul ignore next */\nexport function runAsync(\n  func: (...args: any[]) => void | Promise<any>,\n  ctx: any = {}\n): (...args: any[]) => Promise<any> {\n  return (...args: any[]) => {\n    let async = false;\n\n    const promise = new Promise((resolve, reject) => {\n      // Add async to context\n      ctx.async = () => {\n        async = true;\n\n        return (err: any, value: any) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(value);\n          }\n        };\n      };\n\n      const answer = func.apply(ctx, args as []);\n\n      if (!async) {\n        if (isPromise(answer)) {\n          (answer as Promise<any>).then(resolve, reject);\n        } else {\n          resolve(answer);\n        }\n      }\n    });\n\n    return promise;\n  };\n}\n","/**\n * @barba/core/modules/hooks\n * <br><br>\n * ## Hooks manager.\n *\n * - Register and trigger hooks\n *\n * Hooks can be easily registered:\n *\n * ```js\n * hooks.leave(callback, context);\n * ```\n *\n * @module core/modules/hooks\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HookFunction, HookMethods, HooksAll } from './defs';\n// Modules\nimport { Logger } from './modules/Logger';\n// Utils\nimport { runAsync } from './utils';\n// Types\ninterface IHookInfos {\n  ctx: any;\n  fn: HookFunction;\n}\n\nexport class Hooks extends HookMethods {\n  /**\n   * Allow the use of `hooks[name](cb, ctx)`.\n   */\n  [key: string]: any;\n  // [key in HooksAll]?: any;\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All available hooks.\n   *\n   * See [[HooksAll]]\n   */\n  // TODO: get hooks from defs (DRY)?\n  public all: HooksAll[] = [\n    'ready',\n    'page',\n    'reset',\n    'currentAdded',\n    'currentRemoved',\n    'nextAdded',\n    'nextRemoved',\n    'beforeOnce',\n    'once',\n    'afterOnce',\n    'before',\n    'beforeLeave',\n    'leave',\n    'afterLeave',\n    'beforeEnter',\n    'enter',\n    'afterEnter',\n    'after',\n  ];\n  /**\n   * Registered hooks.\n   *\n   * - Unique hook name\n   * - Associated data set(s) (callback + context)\n   */\n  public registered: Map<HooksAll, Set<IHookInfos>> = new Map();\n\n  constructor() {\n    super();\n    this.init();\n  }\n\n  public init() {\n    this.registered.clear();\n    this.all.forEach(hook => {\n      if (!this[hook]) {\n        this[hook] = (fn: HookFunction, ctx?: any) => {\n          if (!this.registered.has(hook)) {\n            this.registered.set(hook, new Set());\n          }\n          const set = this.registered.get(hook);\n\n          set.add({\n            ctx: ctx || {},\n            fn,\n          });\n        };\n      }\n    });\n  }\n\n  /**\n   * Do hook.\n   *\n   * Trigger registered hooks.\n   */\n  public do(name: HooksAll, ...args: any): Promise<any> {\n    if (this.registered.has(name)) {\n      // Let's start a chain of promises\n      let chain = Promise.resolve();\n\n      this.registered.get(name).forEach(hook => {\n        // Chain async hooks promisified\n        chain = chain.then(() => runAsync(hook.fn, hook.ctx)(...args));\n      });\n\n      return chain.catch(error => {\n        this.logger.debug(`Hook error [${name}]`);\n        this.logger.error(error);\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  public clear(): void {\n    this.all.forEach(hook => {\n      delete this[hook];\n    });\n\n    this.init();\n  }\n\n  /**\n   * Help, print available and registered hooks.\n   */\n  public help(): void {\n    this.logger.info(`Available hooks: ${this.all.join(',')}`);\n    const registered: string[] = [];\n    this.registered.forEach((value, key) => registered.push(key));\n    this.logger.info(`Registered hooks: ${registered.join(',')}`);\n  }\n}\n\nconst hooks = new Hooks();\n\nexport { hooks };\n","/**\n * @barba/core/modules/ignore\n * <br><br>\n * ## Manage ignore options.\n *\n * - cache\n * - prefetch\n *\n * @module core/modules/ignore\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption } from '../defs';\n// Utils\nimport { pathToRegexp } from '../utils/helpers';\nimport { parse } from '../utils/url';\n\nexport class Ignore {\n  private _ignoreAll: boolean;\n  private _ignoreRegexes: RegExp[] = [];\n\n  constructor(ignore: IgnoreOption) {\n    if (typeof ignore === 'boolean') {\n      this._ignoreAll = ignore;\n    } else {\n      const paths = Array.isArray(ignore) ? ignore : [ignore];\n\n      this._ignoreRegexes = paths.map(p => pathToRegexp(p));\n    }\n  }\n\n  public checkHref(href: string): boolean {\n    if (typeof this._ignoreAll === 'boolean') {\n      return this._ignoreAll;\n    }\n\n    const { path } = parse(href);\n\n    return this._ignoreRegexes.some(regex => regex.exec(path) !== null);\n  }\n}\n","/**\n * @barba/core/modules/cache\n * <br><br>\n * ## Cache for storing URL / HTML.\n *\n * @module core/modules/cache\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { CacheAction, CacheRequest, ICacheData, IgnoreOption } from '../defs';\n// Modules\nimport { Ignore } from './Ignore';\n\nexport class Cache extends Ignore {\n  private _state: Map<string, ICacheData> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n  }\n\n  /**\n   * Set value to cache\n   */\n  public set(\n    href: string,\n    request: CacheRequest,\n    action: CacheAction\n  ): ICacheData {\n    this._state.set(href, {\n      action,\n      request,\n    });\n\n    return {\n      action,\n      request,\n    };\n  }\n\n  /**\n   * Get data from cache\n   */\n  public get(href: string): ICacheData {\n    return this._state.get(href);\n  }\n\n  /**\n   * Get request from cache\n   */\n  public getRequest(href: string): CacheRequest {\n    return this._state.get(href).request;\n  }\n\n  /**\n   * Get action from cache\n   */\n  public getAction(href: string): CacheAction {\n    return this._state.get(href).action;\n  }\n\n  /**\n   * Check if value exists into cache\n   */\n  public has(href: string): boolean {\n    /* istanbul ignore else */\n    if (this.checkHref(href)) {\n      return false;\n    }\n    return this._state.has(href);\n  }\n\n  /**\n   * Delete value from cache\n   */\n  public delete(href: string): boolean {\n    return this._state.delete(href);\n  }\n\n  /**\n   * Update cache value\n   */\n  public update(href: string, data: ICacheData): ICacheData {\n    const state = {\n      ...this._state.get(href),\n      ...data,\n    };\n    this._state.set(href, state);\n\n    return state;\n  }\n}\n","/**\n * @barba/core/modules/prevent\n * <br><br>\n * ## Prevent checks.\n *\n * - Gathers all the tests that allow Barba to work and play transitions\n *\n * @module core/modules/prevent\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption, Link, PreventCheck } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n// Utils\nimport { url } from '../utils';\n// Modules\nimport { Ignore } from './Ignore';\n\n/**\n * Make sure the browser supports `history.pushState`.\n */\nconst pushState: PreventCheck = () => !window.history.pushState;\n\n/**\n * Make sure there is an `el` and `href`.\n */\nconst exists: PreventCheck = ({ el, href }) => !el || !href;\n\n/**\n * If the user is pressing ctrl + click, the browser will open a new tab.\n */\nconst newTab: PreventCheck = ({ event }) =>\n  (event as KeyboardEvent).which > 1 ||\n  (event as KeyboardEvent).metaKey ||\n  (event as KeyboardEvent).ctrlKey ||\n  (event as KeyboardEvent).shiftKey ||\n  (event as KeyboardEvent).altKey;\n\n/**\n * If the link has `_blank` target.\n */\nconst blank: PreventCheck = ({ el }) =>\n  el.hasAttribute('target') && (el as Link).target === '_blank';\n\n/**\n * If the domain is the same (in order to avoid pushState cross origin security problem).\n * Note: SVGAElement do not have `protocol` neither `hostname` properties.\n */\nconst corsDomain: PreventCheck = ({ el }) =>\n  ((el as HTMLAnchorElement).protocol !== undefined &&\n    window.location.protocol !== (el as HTMLAnchorElement).protocol) ||\n  ((el as HTMLAnchorElement).hostname !== undefined &&\n    window.location.hostname !== (el as HTMLAnchorElement).hostname);\n\n/**\n * If the port is the same.\n * Note: SVGAElement do not have `port` property.\n */\nconst corsPort: PreventCheck = ({ el }) =>\n  (el as HTMLAnchorElement).port !== undefined &&\n  url.getPort() !== url.getPort((el as HTMLAnchorElement).href);\n\n/**\n * If the link has download attribute.\n */\nconst download: PreventCheck = ({ el }) =>\n  el.getAttribute && typeof el.getAttribute('download') === 'string';\n\n/**\n * If the links contains [data-barba-prevent] or [data-barba-prevent=\"self\"].\n */\nconst preventSelf: PreventCheck = ({ el }) =>\n  el.hasAttribute(`${schemaAttribute.prefix}-${schemaAttribute.prevent}`);\n\n/**\n * If some link ancestor contains [data-barba-prevent=\"all\"].\n */\nconst preventAll: PreventCheck = ({ el }) =>\n  Boolean(\n    el.closest(`[${schemaAttribute.prefix}-${schemaAttribute.prevent}=\"all\"]`)\n  );\n\n/**\n * If the link is the current URL.\n *\n * > Not in the test suite.\n */\nconst sameUrl: PreventCheck = ({ href }) =>\n  url.clean(href) === url.clean() && url.getPort(href) === url.getPort();\n\nexport class Prevent extends Ignore {\n  public suite: string[] = [];\n  public tests: Map<string, PreventCheck> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n    this.init();\n  }\n\n  public init(): void {\n    // Add defaults\n    this.add('pushState', pushState);\n    this.add('exists', exists);\n    this.add('newTab', newTab);\n    this.add('blank', blank);\n    this.add('corsDomain', corsDomain);\n    this.add('corsPort', corsPort);\n    this.add('download', download);\n    this.add('preventSelf', preventSelf);\n    this.add('preventAll', preventAll);\n\n    // Outside of the test suite\n    this.add('sameUrl', sameUrl, false);\n  }\n\n  public add(name: string, check: PreventCheck, suite: boolean = true): void {\n    this.tests.set(name, check);\n    suite && this.suite.push(name);\n  }\n\n  /**\n   * Run individual test\n   */\n  public run(name: string, el: Link, event: Event, href: string): boolean {\n    return this.tests.get(name)({\n      el,\n      event,\n      href,\n    });\n  }\n\n  /**\n   * Run test suite\n   */\n  public checkLink(el: Link, event: Event, href: string): boolean {\n    return this.suite.some(name => this.run(name, el, event, href));\n  }\n}\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class BarbaError extends Error {\n  /* istanbul ignore next */\n  constructor(\n    public error: Error,\n    public label = 'Barba error',\n    ...params: any[]\n  ) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(...params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    /* istanbul ignore else */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, BarbaError);\n    }\n\n    this.name = 'BarbaError';\n  }\n}\n","/**\n * @barba/core/modules/store\n * <br><br>\n * ## Transitions store.\n *\n * - Resolve transition\n * - Manage rules\n *\n * @module core/modules/store\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  IRule,\n  IRules,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionOnce,\n  ITransitionPage,\n  RuleName,\n} from '../defs';\n\n// Modules\nimport { Logger } from './Logger';\n\nexport class Store {\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All registered transitions.\n   */\n  public all: ITransitionPage[] = [];\n  /**\n   * \"Page only\" registered transitions.\n   */\n  public page: ITransitionPage[] = [];\n  /**\n   * \"Once only\" registered transitions.\n   */\n  public once: ITransitionOnce[] = [];\n  /**\n   * Rules for transition resolution.\n   *\n   * Defaults:\n   *\n   * - namespace\n   * - custom\n   */\n  private _rules: IRule[] = [\n    {\n      name: 'namespace',\n      type: 'strings',\n    },\n    {\n      name: 'custom',\n      type: 'function',\n    },\n  ];\n\n  /**\n   * Init store.\n   */\n  constructor(transitions: ITransitionPage[] = []) {\n    /* istanbul ignore else */\n    if (transitions) {\n      // TODO: add check for valid transitions? criteria? (once || enter && leave)\n      this.all = this.all.concat(transitions);\n    }\n    this.update();\n  }\n\n  /**\n   * Add rule or transition.\n   */\n  public add(type: 'rule' | 'transition', data: any): void {\n    switch (type) {\n      case 'rule':\n        // TODO: check for valid rule\n        this._rules.splice(data.position || 0, 0, data.value);\n        break;\n      case 'transition':\n      default:\n        // TODO: check for valid transition\n        this.all.push(data);\n        break;\n    }\n\n    this.update();\n  }\n\n  /**\n   * Resolve transition.\n   */\n  public resolve(\n    data: ITransitionData,\n    filters: ITransitionFilters = {}\n  ): ITransitionOnce | ITransitionPage {\n    // Filter on \"once\"\n    let transitions = filters.once ? this.once : this.page;\n\n    // Filter on \"self\"\n    if (filters.self) {\n      transitions = transitions.filter(t => t.name && t.name === 'self');\n    } else {\n      transitions = transitions.filter(t => !t.name || t.name !== 'self');\n    }\n\n    // All matching transition infos\n    const matching = new Map();\n\n    // Active = first of valid transitions\n    // sorted by directions (from/to, from || to, )\n    const active = transitions.find(t => {\n      let valid = true;\n      const match = {};\n\n      if (filters.self && t.name === 'self') {\n        return true;\n      }\n\n      // Check rules\n      this._rules.reverse().forEach(rule => {\n        if (valid) {\n          valid = this._check(t, rule, data, match);\n          // From/to check\n          if (t.from && t.to) {\n            valid =\n              this._check(t, rule, data, match, 'from') &&\n              this._check(t, rule, data, match, 'to');\n          }\n          if (t.from && !t.to) {\n            valid = this._check(t, rule, data, match, 'from');\n          }\n          if (!t.from && t.to) {\n            valid = this._check(t, rule, data, match, 'to');\n          }\n        }\n      });\n\n      matching.set(t, match);\n\n      return valid;\n    });\n\n    const activeMatch = matching.get(active);\n    const transitionType = [];\n    if (filters.once) {\n      transitionType.push('once');\n    } else {\n      transitionType.push('page');\n    }\n    if (filters.self) {\n      transitionType.push('self');\n    }\n\n    if (activeMatch) {\n      // Log resolved transition\n      const infos: any[] = [active];\n      // Log if matching criteria\n      Object.keys(activeMatch).length > 0 && infos.push(activeMatch);\n\n      this.logger.info(\n        `Transition found [${transitionType.join(',')}]`,\n        ...infos\n      );\n    } else {\n      this.logger.info(`No transition found [${transitionType.join(',')}]`);\n    }\n\n    return active;\n  }\n\n  /**\n   * ### Update store.\n   *\n   * - Reorder transition by priorities\n   * - Get wait indicator\n   * - Get once transitions\n   */\n  public update(): void {\n    // Reorder by priorities\n    this.all = this.all\n      .map(t => this._addPriority(t))\n      .sort((a, b) => a.priority - b.priority)\n      .reverse()\n      .map(t => {\n        delete t.priority;\n\n        return t;\n      });\n    this.page = this.all.filter(\n      t => t.leave !== undefined || t.enter !== undefined\n    ) as ITransitionPage[];\n    this.once = this.all.filter(t => t.once !== undefined) as ITransitionOnce[];\n  }\n\n  /**\n   * ### Check if transition apply.\n   *\n   * Based on rule, page data and optional direction:\n   *\n   * 1. transition has no rule \"property\":\n   *    - always returns true\n   * 2. transition has rule \"property\":\n   *     - \"strings\" should be present on both side (transition + page) and match\n   *     - \"function\" should return true\n   */\n  private _check(\n    transition: ITransitionPage,\n    rule: IRule,\n    data: ITransitionData,\n    match: any,\n    direction?: 'from' | 'to'\n  ): boolean {\n    let isValid = true;\n    let hasMatch = false;\n    const t = transition;\n    const { name, type } = rule;\n    const strRule = name as IRules['strings'];\n    const objRule = name as IRules['object'];\n    const fnName = name as IRules['function'];\n    const base = direction ? t[direction] : t; // = t || t.from || t.to\n    const page = direction === 'to' ? data.next : data.current; // = current || next\n    const exist = direction ? base && base[name] : base[name];\n\n    // If transition rule exists\n    if (exist) {\n      switch (type) {\n        case 'strings':\n        default: {\n          // Array support\n          const names: string[] = Array.isArray(base[strRule])\n            ? (base[strRule] as string[])\n            : [base[strRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[strRule] && names.indexOf(page[strRule]) !== -1) {\n            hasMatch = true;\n          }\n          // If transition prop is different from current, not valid\n          if (names.indexOf(page[strRule]) === -1) {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'object': {\n          // Array support\n          const names: string[] = Array.isArray(base[objRule])\n            ? (base[objRule] as string[])\n            : [base[objRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[objRule]) {\n            if (\n              page[objRule].name &&\n              names.indexOf(page[objRule].name) !== -1\n            ) {\n              hasMatch = true;\n            }\n            // If transition prop is different from current, not valid\n            if (names.indexOf(page[objRule].name) === -1) {\n              isValid = false;\n            }\n          } else {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'function':\n          if (base[fnName](data)) {\n            hasMatch = true;\n          } else {\n            isValid = false;\n          }\n          break;\n      }\n\n      if (hasMatch) {\n        if (direction) {\n          match[direction] = match[direction] || {};\n          match[direction][name] = t[direction][name];\n        } else {\n          match[name] = t[name];\n        }\n      }\n    }\n\n    return isValid;\n  }\n\n  /**\n   * ### Calculate transition priority.\n   *\n   * Based on:\n   *\n   * - rule \"position\" (index) give tens, hundreds, thousands, \n   * - from/to properties give units (0, 1 or 2)\n   */\n  private _calculatePriority(\n    t: ITransitionPage,\n    ruleName: RuleName,\n    ruleIndex: number\n  ): number {\n    let priority = 0;\n\n    if (\n      t[ruleName] ||\n      (t.from && t.from[ruleName]) ||\n      (t.to && t.to[ruleName])\n    ) {\n      priority += Math.pow(10, ruleIndex);\n\n      if (t.from && t.from[ruleName]) {\n        priority += 1;\n      }\n      if (t.to && t.to[ruleName]) {\n        priority += 2;\n      }\n    }\n\n    return priority;\n  }\n\n  private _addPriority(t: ITransitionPage): ITransitionPage {\n    t.priority = 0;\n    let priority = 0;\n\n    this._rules.forEach((rule, i) => {\n      const { name } = rule;\n      const index = i + 1;\n\n      priority += this._calculatePriority(t, name, index);\n    });\n\n    t.priority = priority;\n\n    return t;\n  }\n}\n","/**\n * @barba/core/modules/transitions\n * <br><br>\n * ## Transitions manager.\n *\n * - Handle hooks and transition lifecycle\n *\n * @module core/modules/transitions\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  HooksTransition,\n  HooksTransitionMap,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionOnce,\n  ITransitionPage,\n  Wrapper,\n} from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { dom, helpers, runAsync } from '../utils';\n// Modules\nimport { BarbaError } from './Error';\nimport { Logger } from './Logger';\nimport { Store } from './Store';\n\nexport class Transitions {\n  public logger: Logger = new Logger('@barba/core');\n  public store: Store;\n  private _running: boolean = false;\n\n  constructor(transitions: ITransitionPage[] = []) {\n    this.store = new Store(transitions);\n  }\n\n  /**\n   * Get resolved transition\n   *\n   * - based on data\n   */\n  public get(\n    data: ITransitionData,\n    filters?: ITransitionFilters\n  ): ITransitionOnce | ITransitionPage {\n    return this.store.resolve(data, filters);\n  }\n\n  /**\n   * Animation running status.\n   */\n  get isRunning(): boolean {\n    return this._running;\n  }\n  set isRunning(status: boolean) {\n    this._running = status;\n  }\n\n  /**\n   * Check for registered once transition(s).\n   */\n  get hasOnce(): boolean {\n    return this.store.once.length > 0;\n  }\n\n  /**\n   * Check for registered self transition.\n   */\n  get hasSelf(): boolean {\n    return this.store.all.some(t => t.name === 'self');\n  }\n\n  /**\n   * ### Wait indicator.\n   *\n   * Tells Barba to get next page data<br>\n   * before starting the resolution<br>\n   * because some registered transitions need<br>\n   * next page data to be resolved (eg: `sync: true`, `to: { namespace }`, )\n   */\n  get shouldWait(): boolean {\n    return this.store.all.some(t => (t.to && !t.to.route) || t.sync);\n  }\n\n  /**\n   * ### Do \"once\" transition.\n   *\n   * Hooks: see [[HooksOnce]].\n   */\n  public async doOnce({\n    data,\n    transition,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionOnce;\n  }) {\n    const t = transition || {};\n    this._running = true;\n\n    try {\n      await this._doAsyncHook('beforeOnce', data, t);\n      await this.once(data, t);\n      await this._doAsyncHook('afterOnce', data, t);\n    } catch (error) {\n      this._running = false;\n\n      this.logger.debug('Transition error [before/after/once]');\n      this.logger.error(error);\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * ### Do \"page\" transition.\n   *\n   * Hooks: see [[HooksPage]].\n   *\n   * `sync: false` (default) order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. leave\n   * 4. afterLeave\n   * 5. beforeEnter\n   * 6. enter\n   * 7. afterEnter\n   * 8. after\n   *\n   * `sync: true` order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. beforeEnter\n   * 4. leave & enter\n   * 5. afterLeave\n   * 6. afterEnter\n   * 7. after\n   */\n  public async doPage({\n    data,\n    transition,\n    page,\n    wrapper,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionPage;\n    page: Promise<string | void>;\n    wrapper: Wrapper;\n  }) {\n    const t = transition || {};\n    const sync = t.sync === true || false;\n\n    this._running = true;\n\n    try {\n      // Check sync mode, wait for next content\n      if (sync) {\n        await helpers.update(page, data);\n      }\n\n      await this._doAsyncHook('before', data, t);\n\n      if (sync) {\n        try {\n          await this.add(data, wrapper);\n          // Before actions\n          await this._doAsyncHook('beforeLeave', data, t);\n          await this._doAsyncHook('beforeEnter', data, t);\n\n          // Actions\n          await Promise.all([this.leave(data, t), this.enter(data, t)]);\n\n          // After actions\n          await this._doAsyncHook('afterLeave', data, t);\n          await this._doAsyncHook('afterEnter', data, t);\n        } catch (error) {\n          // this.logger.debug('Transition error [sync]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(error, 'Transition error [sync]');\n          }\n        }\n      } else {\n        let leaveResult: any = false;\n\n        try {\n          // Leave\n          await this._doAsyncHook('beforeLeave', data, t);\n\n          leaveResult = await Promise.all([\n            this.leave(data, t),\n            helpers.update(page, data),\n          ]).then(values => values[0]);\n\n          await this._doAsyncHook('afterLeave', data, t);\n\n          // TODO: check here \"valid\" page result\n          // before going further\n        } catch (error) {\n          // this.logger.debug('Transition error [before/after/leave]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              error,\n              'Transition error [before/after/leave]'\n            );\n          }\n        }\n\n        try {\n          // Enter\n          /* istanbul ignore else */\n          if (leaveResult !== false) {\n            await this.add(data, wrapper);\n\n            await this._doAsyncHook('beforeEnter', data, t);\n            await this.enter(data, t, leaveResult);\n            await this._doAsyncHook('afterEnter', data, t);\n          }\n        } catch (error) {\n          // this.logger.debug('Transition error [before/after/enter]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              error,\n              'Transition error [before/after/enter]'\n            );\n          }\n        }\n      }\n\n      // Remove current contaienr\n      await this.remove(data);\n\n      await this._doAsyncHook('after', data, t);\n    } catch (error) {\n      this._running = false;\n\n      // If \"custom/specific\" barba error.\n      /* istanbul ignore else */\n      if (error.name && error.name === 'BarbaError') {\n        this.logger.debug(error.label);\n        this.logger.error(error.error);\n\n        throw error;\n      }\n\n      this.logger.debug('Transition error [page]');\n      this.logger.error(error);\n\n      throw error;\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * Once hook + async \"once\" transition.\n   */\n  public async once(data: ITransitionData, t: ITransitionOnce): Promise<void> {\n    await hooks.do('once', data, t);\n\n    return t.once ? runAsync(t.once, t)(data) : Promise.resolve();\n  }\n\n  /**\n   * Leave hook + async \"leave\" transition.\n   */\n  public async leave(data: ITransitionData, t: ITransitionPage): Promise<any> {\n    await hooks.do('leave', data, t);\n\n    return t.leave ? runAsync(t.leave, t)(data) : Promise.resolve();\n  }\n\n  /**\n   * Enter hook + async \"enter\" transition.\n   */\n  public async enter(\n    data: ITransitionData,\n    t: ITransitionPage,\n    leaveResult?: any\n  ): Promise<void> {\n    await hooks.do('enter', data, t);\n\n    return t.enter\n      ? runAsync(t.enter, t)(data, leaveResult)\n      : Promise.resolve();\n  }\n\n  /**\n   * Add next container.\n   */\n  public async add(data: ITransitionData, wrapper: Wrapper): Promise<void> {\n    dom.addContainer(data.next.container, wrapper);\n    hooks.do('nextAdded', data);\n  }\n\n  /**\n   * Remove current container.\n   */\n  public async remove(data: ITransitionData): Promise<void> {\n    dom.removeContainer(data.current.container);\n    hooks.do('currentRemoved', data);\n  }\n\n  private _isTransitionError(error: any) {\n    if (error.message) {\n      // Errors from request\n      return !/Timeout error|Fetch error/.test(error.message);\n    }\n\n    if (error.status) {\n      // Errors from request\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Do hooks + async transition methods.\n   */\n  private async _doAsyncHook(\n    hook: HooksTransition,\n    data: ITransitionData,\n    t: HooksTransitionMap\n  ): Promise<void> {\n    await hooks.do(hook, data, t);\n\n    return t[hook] ? runAsync(t[hook], t)(data) : Promise.resolve();\n  }\n}\n","/**\n * @barba/core/modules/views\n * <br><br>\n * ## Views manager.\n *\n * @module core/modules/views\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HooksView, IView, IViewData } from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { runAsync } from '../utils';\n// Types\ntype Hook = (data: IViewData) => Promise<void>;\n\nexport class Views {\n  /**\n   * Available hook names for views.\n   */\n  public names: HooksView[] = [\n    'beforeLeave',\n    'afterLeave',\n    'beforeEnter',\n    'afterEnter',\n  ];\n  /**\n   * Registered views by namespace.\n   */\n  public byNamespace: Map<string, IView> = new Map();\n\n  /**\n   * Init views.\n   */\n  constructor(views: IView[]) {\n    if (views.length === 0) {\n      return;\n    }\n\n    // TODO: add check\n    // for valid views? criteria? (namespace property, string ?)\n    // or duplicate\n    views.forEach(view => {\n      this.byNamespace.set(view.namespace, view);\n    });\n\n    this.names.forEach(name => {\n      hooks[name](this._createHook(name));\n    });\n  }\n\n  /**\n   * Create the hook method.\n   *\n   * - get view based on namespace\n   * - execute callback with transition data\n   */\n  private _createHook(name: HooksView): Hook {\n    return data => {\n      const { namespace } = name.match(/enter/i) ? data.next : data.current;\n      const view = this.byNamespace.get(namespace);\n\n      // TODO: manage self\n      // if (view && data.trigger !== 'self') {\n      if (view && view[name]) {\n        return runAsync(view[name], view)(data);\n      }\n\n      return Promise.resolve();\n    };\n  }\n}\n","// Element.prototype.matches polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    (Element as any).prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n}\n\n// Element.prototype.closest polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function closest(s: string) {\n    let el = this;\n\n    do {\n      if (el.matches(s)) {\n        return el;\n      }\n\n      el = (el.parentElement || el.parentNode) as Element;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}\n","/**\n * @module core/schemas\n */\n\n// Definitions\nimport { ISchemaPage } from '../defs';\n\n/**\n * See [[ISchemaPage]]\n */\nexport const schemaPage: ISchemaPage = {\n  container: null,\n  html: '',\n  namespace: '',\n  url: {\n    hash: '',\n    href: '',\n    path: '',\n    port: null,\n    query: {},\n  },\n};\n","/**\n * @barba/core\n * <br><br>\n * ## Barba core object\n *\n * Main methods:\n *\n * - `.init()` for initialization with options\n * - `.use()` for plugins\n *\n * @module core\n */\n\n/***/\n\nimport { version } from '../package.json';\n// Definitions\nimport {\n  IBarbaOptions,\n  IBarbaPlugin,\n  IgnoreOption,\n  ISchemaPage,\n  ITransitionData,\n  ITransitionOnce,\n  ITransitionPage,\n  Link,\n  LinkEvent,\n  RequestCustomError,\n  RequestErrorOrResponse,\n  SchemaAttributeValues,\n  Trigger,\n  Wrapper,\n} from './defs';\n// Hooks\nimport { hooks } from './hooks';\n// Modules\nimport { Cache } from './modules/Cache';\nimport { Logger } from './modules/Logger';\nimport { Prevent } from './modules/Prevent';\nimport { Transitions } from './modules/Transitions';\nimport { Views } from './modules/Views';\n// Polyfills\nimport './polyfills';\n// Schemas\nimport { schemaAttribute } from './schemas/attribute';\nimport { schemaPage } from './schemas/page';\n// Utils\nimport { dom, helpers, history, request, url } from './utils';\n\nexport class Core {\n  /**\n   * Version.\n   */\n  public version: string = version;\n  /**\n   * Schemas.\n   */\n  public schemaPage: ISchemaPage = schemaPage;\n  /**\n   * Logger class, allows plugins to create Logger.\n   */\n  public Logger: typeof Logger = Logger;\n  /**\n   * Barba logger.\n   */\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * Plugins.\n   */\n  public plugins: Array<IBarbaPlugin<any>> = [];\n  /**\n   * Options\n   */\n  public timeout: number;\n  public cacheIgnore: IgnoreOption;\n  public prefetchIgnore: IgnoreOption;\n  public preventRunning: boolean;\n  /**\n   * Hooks\n   */\n  public hooks = hooks;\n  /**\n   * Modules.\n   */\n  // public history: History;\n  public cache: Cache;\n  public prevent: Prevent;\n  public transitions: Transitions;\n  public views: Views;\n  /**\n   * Utils.\n   */\n  public dom = dom;\n  public helpers = helpers;\n  public history = history;\n  public request = request;\n  public url = url;\n\n  private _data: ITransitionData;\n  private _requestCustomError: RequestCustomError;\n  private _wrapper: Wrapper;\n\n  /**\n   * ### Init plugin with options.\n   *\n   * See [[IBarbaPlugin]] for more details.\n   */\n  public use<T>(plugin: IBarbaPlugin<T>, options?: T): void {\n    const installedPlugins = this.plugins;\n\n    // Plugin installation\n    if (installedPlugins.indexOf(plugin) > -1) {\n      this.logger.warn(`Plugin [${plugin.name}] already installed.`);\n\n      return;\n    }\n\n    if (typeof plugin.install !== 'function') {\n      this.logger.warn(`Plugin [${plugin.name}] has no \"install\" method.`);\n\n      return;\n    }\n\n    plugin.install(this, options);\n    installedPlugins.push(plugin);\n  }\n\n  /**\n   * ### Init barba with options.\n   *\n   * See [[IBarbaOptions]] for more details.\n   *\n   * Default values are:\n   *\n   * - transitions: `[]`\n   * - views: `[]`\n   * - schema: [[SchemaAttribute]]\n   * - timeout: `2e3`\n   * - cacheIgnore: `false`\n   * - prefetchIgnore: `false`\n   * - preventRunning: `false`\n   * - prevent: `null`,\n   * - debug: `false`\n   * - logLevel: `'debug'`\n   */\n  public init(\n    /** @ignore */ {\n      transitions = [],\n      views = [],\n      schema = schemaAttribute,\n      requestError,\n      timeout = 2e3,\n      cacheIgnore = false,\n      prefetchIgnore = false,\n      /* istanbul ignore next */\n      preventRunning = false,\n      prevent: preventCustom = null,\n      debug = false,\n      logLevel = 'off',\n    }: IBarbaOptions = {}\n  ) {\n    // 0. Set logger level and print version\n    Logger.setLevel(debug === true ? 'debug' : logLevel);\n    this.logger.info(this.version);\n\n    // 1. Manage options\n    Object.keys(schema).forEach(k => {\n      const attr = k as SchemaAttributeValues;\n\n      /* istanbul ignore else */\n      if (schemaAttribute[attr]) {\n        schemaAttribute[attr] = schema[attr];\n      }\n    });\n    this._requestCustomError = requestError;\n    this.timeout = timeout;\n    this.cacheIgnore = cacheIgnore;\n    this.prefetchIgnore = prefetchIgnore;\n    this.preventRunning = preventRunning;\n\n    // 2. Get and check wrapper\n    this._wrapper = this.dom.getWrapper();\n    if (!this._wrapper) {\n      throw new Error('[@barba/core] No Barba wrapper found');\n    }\n    this._wrapper.setAttribute('aria-live', 'polite'); // A11y\n\n    // 3. Init pages (get \"current\" data)\n    this._resetData();\n\n    const { current } = this.data;\n\n    if (!current.container) {\n      throw new Error('[@barba/core] No Barba container found');\n    }\n\n    // 4. Init other modules\n    this.cache = new Cache(cacheIgnore);\n    this.prevent = new Prevent(prefetchIgnore);\n    this.transitions = new Transitions(transitions);\n    this.views = new Views(views);\n\n    // Add prevent custom\n    if (preventCustom !== null) {\n      if (typeof preventCustom !== 'function') {\n        throw new Error('[@barba/core] Prevent should be a function');\n      }\n\n      this.prevent.add('preventCustom', preventCustom);\n    }\n\n    // 5. Use \"current\" data\n    // Init history\n    this.history.init(current.url.href, current.namespace);\n    // Add to cache\n    // TODO: do not cache renderer HTML, only request results\n    // this.cache.set(current.url.href, Promise.resolve(current.html), 'init');\n\n    // 6. Bind context\n    this._onLinkEnter = this._onLinkEnter.bind(this);\n    this._onLinkClick = this._onLinkClick.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._bind();\n\n    // 7. Init plugins\n    this.plugins.forEach(plugin => plugin.init());\n\n    // 8. Barba ready\n    // Set next + trigger for once and `beforeEnter`/`afterEnter` view on page load.\n    const onceData = this.data;\n\n    onceData.trigger = 'barba';\n    onceData.next = onceData.current;\n    onceData.current = { ...this.schemaPage };\n    this.hooks.do('ready', onceData);\n\n    // 9. Finally, do once\n    this.once(onceData);\n\n    // Clean data for first barba transition\n    this._resetData();\n  }\n\n  public destroy(): void {\n    this._resetData();\n    this._unbind();\n    this.history.clear();\n    this.hooks.clear();\n    this.plugins = [];\n  }\n\n  get data(): ITransitionData {\n    return this._data;\n  }\n\n  get wrapper(): HTMLElement {\n    return this._wrapper;\n  }\n\n  /**\n   * ### Force a page change without Barba transition.\n   */\n  public force(href: string): void {\n    // DEV\n    // Can be used waiting animation cancellation management\n    window.location.assign(href);\n  }\n\n  /**\n   * ### Go for a Barba transition.\n   *\n   * Manage \"self page\" href:\n   *\n   * - if same url and no self transition, keep default behavior\n   *   - link: reload the page\n   *   - anchor: scroll to\n   * - if same url with self transition, use it\n   * - then start a page transition.\n   */\n  public go(\n    href: string,\n    trigger: Trigger = 'barba',\n    e?: LinkEvent | PopStateEvent\n  ): Promise<void> {\n    // If animation running, force reload\n    if (this.transitions.isRunning) {\n      this.force(href);\n\n      return;\n    }\n\n    let self = false;\n\n    // Check prevent sameURL against current history\n    // + state check\n    // + update trigger with direction\n    if (trigger === 'popstate') {\n      self =\n        this.history.current &&\n        this.url.getPath(this.history.current.url) === this.url.getPath(href);\n    } else {\n      self = this.prevent.run('sameUrl', null, null, href);\n    }\n\n    if (self && !this.transitions.hasSelf) {\n      return;\n    }\n\n    trigger = this.history.change(href, trigger, e);\n\n    if (e) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n\n    return this.page(href, trigger, self);\n  }\n\n  /**\n   * ### Start an \"once\" transition.\n   *\n   * If some registered \"once\" transition,\n   * get the \"resolved\" transition from the store and start it.\n   */\n  public async once(readyData: ITransitionData): Promise<void> {\n    await this.hooks.do('beforeEnter', readyData);\n\n    // Check if once transition\n    if (this.transitions.hasOnce) {\n      const transition = this.transitions.get(readyData, {\n        once: true,\n      }) as ITransitionOnce;\n\n      await this.transitions.doOnce({ transition, data: readyData });\n    }\n\n    await this.hooks.do('afterEnter', readyData);\n  }\n\n  /**\n   * ### Start a \"page\" transition.\n   *\n   * 1. If no running transition, updates data with full URL properties and trigger.\n   * 2. Get page from cache or init request.\n   * 3. Wait if some transitions need \"next\" data (`sync: true`, `to: `).\n   * 4. Manage the history, depending on trigger.\n   * 5. Get \"data\" and trigger \"go\" hook.\n   * 6. Get the \"resolved\" transition from the store and start it.\n   * 7. Update title and reset data (current, next = undefined).\n   *\n   * > If \"self\", use the \"self\" transition\n   */\n  public async page(\n    href: string,\n    trigger: Trigger,\n    self: boolean\n  ): Promise<void> {\n    this.data.next.url = {\n      href,\n      ...this.url.parse(href),\n    };\n    this.data.trigger = trigger;\n\n    const page = this.cache.has(href)\n      ? this.cache.update(href, { action: 'click' }).request\n      : this.cache.set(\n          href,\n          this.request(\n            href,\n            this.timeout,\n            this.onRequestError.bind(this, trigger)\n          ),\n          'click'\n        ).request;\n\n    // Need to wait before getting the right transition\n    if (this.transitions.shouldWait) {\n      await helpers.update(page, this.data);\n    }\n\n    const data = this.data;\n\n    // Hook: between trigger and transition\n    // Can be used to resolve \"route\"\n    await this.hooks.do('page', data);\n\n    try {\n      const transition = this.transitions.get(data, {\n        once: false,\n        self,\n      }) as ITransitionPage;\n\n      await this.transitions.doPage({\n        data,\n        page,\n        transition,\n        wrapper: this._wrapper,\n      });\n\n      this._resetData();\n    } catch (error) {\n      // Something went wrong (rejected promise, error, 404, 505, other)\n      // TODO: manage / use cases for cancellation\n      // this.logger.debug('Transition cancelled');\n\n      // If transition error and no debug mode, force reload page.\n      /* istanbul ignore else */\n      if (Logger.getLevel() === 0) {\n        this.force(data.current.url.href);\n      }\n    }\n  }\n\n  /**\n   * When a request error occurs.\n   *\n   * Allow the user to manage request error. (E.g: 404)\n   */\n  public onRequestError(trigger: Trigger, ...args: any): boolean {\n    // Cancel transition status\n    this.transitions.isRunning = false;\n\n    const [href, response]: [string, RequestErrorOrResponse] = args;\n    const action = this.cache.getAction(href);\n    this.cache.delete(href);\n\n    // Custom requestError returning false will return here.\n    if (\n      this._requestCustomError &&\n      this._requestCustomError(trigger, action, href, response) === false\n    ) {\n      return false;\n    }\n\n    // Force page change\n    if (action === 'click') {\n      this.force(href);\n    }\n    return false;\n  }\n\n  /**\n   * Programmatically prefetch\n   */\n  public prefetch(href: string) {\n    // Already in cache\n    /* istanbul ignore next */\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, 'barba')\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'prefetch'\n    );\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _bind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.addEventListener('mouseover', this._onLinkEnter);\n      document.addEventListener('touchstart', this._onLinkEnter);\n    }\n    document.addEventListener('click', this._onLinkClick);\n    window.addEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _unbind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.removeEventListener('mouseover', this._onLinkEnter);\n      document.removeEventListener('touchstart', this._onLinkEnter);\n    }\n    document.removeEventListener('click', this._onLinkClick);\n    window.removeEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * When a element is entered.\n   *\n   * Get valid link element.\n   * Cache URL if needed.\n   */\n  private _onLinkEnter(e: LinkEvent): void {\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    const href = this.dom.getHref(link);\n\n    if (this.prevent.checkHref(href)) {\n      return;\n    }\n\n    // Already in cache\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, link)\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'enter'\n    );\n  }\n\n  /**\n   * When an element is clicked.\n   *\n   * Get valid link element.\n   * Prevent same URL.\n   * Go for a Barba transition.\n   */\n  private _onLinkClick(e: LinkEvent): void {\n    // This use `prevent.checkLink` under the hood to get eligible link.\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    if (this.transitions.isRunning && this.preventRunning) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      return;\n    }\n\n    this.go(this.dom.getHref(link), link, e);\n  }\n\n  /**\n   * When History state changes.\n   *\n   * Get \"href\" from URL\n   * Go for a Barba transition.\n   */\n  private _onStateChange(e: PopStateEvent): void {\n    this.go(this.url.getHref(), 'popstate', e);\n  }\n\n  /**\n   * Get a valid link ancestor.\n   *\n   * Check for a \"href\" attribute.\n   * Then check if eligible for Barba.\n   */\n  private _getLinkElement(e: LinkEvent): Link {\n    let el = e.target as Link;\n\n    while (el && !this.dom.getHref(el)) {\n      el = (el as HTMLElement).parentNode as Link;\n    }\n\n    // Check prevent\n    if (!el || this.prevent.checkLink(el, e, this.dom.getHref(el))) {\n      return;\n    }\n\n    return el;\n  }\n\n  /**\n   * Reset pages data.\n   *\n   * Set \"current\" and unset \"next\".\n   */\n  private _resetData() {\n    const href = this.url.getHref();\n    const current = {\n      container: this.dom.getContainer(),\n      html: this.dom.getHtml(),\n      namespace: this.dom.getNamespace(),\n      url: {\n        href,\n        ...this.url.parse(href),\n      },\n    };\n\n    this._data = {\n      current,\n      next: { ...this.schemaPage },\n      trigger: undefined,\n    };\n\n    this.hooks.do('reset', this.data);\n  }\n}\n\nconst core = new Core();\n\nexport default core;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}